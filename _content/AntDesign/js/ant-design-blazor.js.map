{"version":3,"sources":["../node_modules/browser-pack/_prelude.js","core/JsInterop/ObservableApi/mutationObserver.ts","core/JsInterop/ObservableApi/observableApi.ts","core/JsInterop/ObservableApi/resizeObserver.ts","core/JsInterop/interop.ts","core/JsInterop/modules/components/backtopHelper.ts","core/JsInterop/modules/components/export.ts","core/JsInterop/modules/components/iconHelper.ts","core/JsInterop/modules/components/inputHelper.ts","core/JsInterop/modules/components/mentionsHelper.ts","core/JsInterop/modules/components/modalHelper.ts","core/JsInterop/modules/components/overlay.ts","core/JsInterop/modules/components/overlayHelper.ts","core/JsInterop/modules/components/tableHelper.ts","core/JsInterop/modules/components/uploadHelper.ts","core/JsInterop/modules/dom/dragHelper.ts","core/JsInterop/modules/dom/eventHelper.ts","core/JsInterop/modules/dom/exports.ts","core/JsInterop/modules/dom/infoHelper.ts","core/JsInterop/modules/dom/manipulationHelper.ts","core/JsInterop/modules/dom/types.ts","core/JsInterop/modules/enums.ts","core/JsInterop/modules/stateProvider.ts","core/JsInterop/modules/styleHelper.ts","main.ts"],"names":["r","e","n","t","o","i","f","c","require","u","a","Error","code","p","exports","call","length","1","module","infoHelper_1","mutationObserver","key","invoker","observer","arguments","undefined","MutationObserver","mutations","observerCallback","mutationObservers","set","element","options","get","domElement","infoHelper","observe","this","disconnect","delete","entriesJson","JSON","stringify","invokeMethodAsync","Map","resizeObserver_1","Object","defineProperty","enumerable","resizeObserver","mutationObserver_1","ResizeObserverEntry","window","ResizeObserver","entries","observerCallBack","resizeObservers","unobserve","mappedEntries","Array","forEach","entry","mEntry","borderBoxSize","blockSize","inlineSize","contentBoxSize","contentRect","x","y","width","height","top","right","bottom","left","target","push","stateProvider_1","state","observable","exports_1","domInfoHelper","domTypes","domManipulationHelper","eventHelper","styleHelper_1","styleHelper","export_1","backtopHelper","iconHelper","inputHelper","mentionsHelper","modalHelper","overlayHelper","tableHelper","uploadHelper","dragHelper_1","enableDraggable","disableDraggable","resetModalPosition","log","text","console","dom","slideTo","scrollTop","backtopHelper_1","overlayHelper_1","uploadHelper_1","mentionsHelper_1","modalHelper_1","inputHelper_1","tableHelper_1","iconHelper_1","scriptUrl","script","document","querySelector","createElement","setAttribute","body","appendChild","result","scrollHeight","currentStyle","parseFloat","getComputedStyle","defaultView","getPropertyValue","is","NaN","minRows","maxRows","objReference","objReferenceDict","id","eventCallbackRegistry","resizeTextArea","addEventListener","getTextAreaInfo","disposeResizeTextArea","removeEventListener","dims","rowHeight","offsetHeight","oldHeight","style","oldRows","rows","Math","trunc","newHeight","max","overflowY","scrollWidth","position","value","selectionStart","selectionEnd","mentionsOnWindowClick","offset","getOffset","elem","InputCaret","mentionsObj","inputor","_classCallCheck","getPos","domInputor","getPosition","pos","format","replace","test","navigator","userAgent","inputorValue","start_range","slice","end_range","html","Mirror","create","rect","getBoundingClientRect","scrollLeft","$mirror","AntDesign","interop","css","mirrorCss","innerHTML","parentElement","append","_this","zIndex","css_attr","flag","oRect","offsetLeft","offsetTop","removeChild","selector","htmlElement","count","ele","hasAttribute","activeElement","blur","setTimeout","focus","getActiveElement","focusDialog","querySelectorAll","parentNode","Placement","TriggerBoundyAdjustMode","observableApi_1","end","overlay","className","indexOf","start","lastIndexOf","substr","classList","remove","isContainerBody","scrollbarSize","horizontalHeight","innerHeight","documentElement","clientHeight","verticalWidth","innerWidth","clientWidth","container","offsetWidth","resize","blazorId","resizing","bind","trigger","mutating","attributes","characterData","childList","subtree","attributeOldValue","characterDataOldValue","onScroll","diff","isTriggerFixed","lastScrollPosition","pageYOffset","Overlay","reversePositionValue","containerInfo","overlayInfo","selectedVerticalPosition","sanitizedPosition","getAdjustedBottom","calculatePosition","overlayPreset","duringInit","lastStyleMutation","cssText","dispose","contains","applyLocation","firstTime","offsetParent","recentPlacement","placement","getKeyElementDimensions","restoreInitialPlacement","calculationsToPerform","getNominalPositions","size","adjustToContainerBoundaries","sanitizeCalculatedPositions","triggerPrefixCls","add","assign","getMaxZIndex","selectedHorizontalPosition","getAdjustedRight","containerBoundarySize","getContainerBoundarySize","directionsToCalculate","Set","boundyAdjustMode","None","horizontalPosition","getHorizontalPosition","verticalPosition","getVerticalPosition","initialPlacement","appliedStylePositionMap","horizontal","vertical","verticalCalculation","setVerticalCalculation","horizontalCalculation","setHorizontalCalculation","info","parentInfo","containerId","absoluteTop","triggerInfo","absoluteLeft","triggerHtml","outerHTML","class","appliedCssPosition","overlay_style_top","overlay_style_bottom","overlay_style_left","overlay_style_right","pageXOffset","containerIsBody","scrollbars","overlayConstraints","placment","applyPlacement","currentPlacement","newPlacement","stringMach","getInfo","calculateScrollBarSizes","triggerPosition","clientTop","clientLeft","has","adjustVerticalToContainerBoundaries","adjustHorizontalToContainerBoundaries","getWindow","scroll","getScroll","bodyBoundarySize","InScroll","setBodyBoundayrSize","parentIsInsignificant","verticalScrollBasedOnParent","horizontalScrollBasedOnParent","visibleIn","boundary","positionCache","selectedPositionCache","placementCache","horizontalCalculationCache","visibleWidthBeforeAdjustment","visibleWidthInBodyBeforeAdjustment","visibleWidthAfterAdjustment","visibleWidthInBodyAfterAdjustment","overlayFitsContainer","getOverlayVisibleWidth","isContainerOverBody","getHorizontalAdjustment","verticalCalculationCache","visibleHeightBeforeAdjustment","visibleHeightInBodyBeforeAdjustment","visibleHeightAfterAdjustment","visibleHeightInBodyAfterAdjustment","getOverlayVisibleHeight","getVerticalAdjustment","type","endExpressedAsLeft","endExpressedAsTop","reverseVerticalPlacementMap","reverseHorizontalPlacementMap","triggerIsWrappedInDiv","childNodes","childElement","LeftTop","RightTop","triggerTop","triggerHeight","overlayHeight","constraints","BottomLeft","BottomCenter","Bottom","BottomRight","verticalOffset","Left","Right","TopLeft","TopCenter","Top","TopRight","triggerBottom","LeftBottom","RightBottom","triggerLeft","triggerWidth","overlayWidth","horizontalOffset","triggerRight","containerDimension","overlayDimension","triggerBoundyAdjustMode","findAncestorWithZIndex","removeHiddenClass","getFirstValidChild","arrowPointAtCenter","arrowCenterPlacementMatch","isFixedPosition","overlay_1","overlaySelector","triggerSelector","containerSelector","overlayTop","overlayLeft","overlayElement","containerElement","triggerElement","addElementTo","overlayPresets","overlayRegistry","addOverlayToContainer","preventKeyOnCondition","bodyRef","tableRef","headerRef","scrollX","scrollY","bindScroll","SetScrollPositionClassName","pingLeft","pingRight","abs","btn","fileClickEvent","stopPropagation","fileId","currentTarget","nodeValue","getElementById","click","files","fileInfo","file","objectUrl","getObjectURL","fileName","name","objectURL","url","URL","createObjectURL","webkitURL","index","data","headers","instance","percentMethod","successMethod","errorMethod","method","formData","FormData","req","XMLHttpRequest","onreadystatechange","readyState","status","responseText","upload","onprogress","event","percent","floor","loaded","onerror","open","header","setRequestHeader","send","throttle","fn","threshold","timeout","Date","_len","args","_key","curTime","clearTimeout","apply","eventMap","defaultOptions","inViewport","Dragger","_container","triggler","_triggler","_options","onMousedown","onMouseup","onMousemove","onResize","_style","_isFirst","dragInViewport","_this2","_state","isInDrag","mX","clientX","mY","clientY","_getContainerPos","getContainerPos","domMaxY","domMaxX","getAttribute","domStartX","domStartY","_getContainerPos2","newDomX","nowX","nowY","disX","disY","newDomY","margin","paddingBottom","parseInt","dragger","bindDrag","unbindDrag","resetContainerStyle","eventType","eventName","evt","createEvent","initEvent","dispatchEvent","preventDefault","callback","k","obj","json","v","Node","Window","debounce","firstElementChild","addDomEventListener","inputElement","keys","map","toUpperCase","preventKeys","check","func","wait","immediate","_arguments","context","callNow","manipulationHelper_1","manipulationHelper","eventHelper_1","absolutePosition","getElementAbsolutePos","round","box","res","viewportElement","innerText","concat","_toConsumableArray","reduce","node","nodeName","toLowerCase","zIndexAsString","Number","isNaN","enums","addElement","elementSelector","parent","delElement","clipboard","writeText","then","err","error","fallbackCopyTextToClipboard","textArea","select","msg","execCommand","noScroll","option","FocusBehavior","FocusAtLast","HTMLElement","preventScroll","HTMLInputElement","HTMLTextAreaElement","FocusAndSelectAll","FocusAtFirst","setSelectionRange","scrollIntoView","behavior","block","inline","targetPageY","timer","setInterval","currentY","speed","ceil","clearInterval","scrollTo","currInput","tagName","inputs","getElementsByTagName","next","oldBodyCache","oldBodyCacheStack","hasScrollbar","overflow","addCls","pop","_a","_b","_c","removeCls","objReferenceName","State","getInstance","_element$classList","clsName","_element$classList2","query","matchMedia","matches","styleProp","hasOwnProperty"],"mappings":"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","file":"ant-design-blazor.js","sourcesContent":["(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c=\"function\"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error(\"Cannot find module '\"+i+\"'\");throw a.code=\"MODULE_NOT_FOUND\",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u=\"function\"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()","﻿import { infoHelper as domInfoHelper } from '../modules/dom/infoHelper';\n\nexport class mutationObserver {\n  // @ts-ignore: TS2304: Cannot find name 'MutationObserver'\n  private static mutationObservers: Map<string, MutationObserver> = new Map<string, MutationObserver>();\n\n\n  static create(key: string, invoker, isDotNetInvoker: boolean = true) {\n    // @ts-ignore: TS2304: Cannot find name 'MutationObserver'\n    let observer;\n\n    if (isDotNetInvoker) {\n      observer = new MutationObserver(mutations => mutationObserver.observerCallback(mutations, invoker))\n    } else {\n      observer = new MutationObserver(mutations => invoker(mutations))\n    }\n    mutationObserver.mutationObservers.set(key, observer)\n  }\n\n  static observe(key: string, element, options?: MutationObserverInit) {\n    const observer = mutationObserver.mutationObservers.get(key);\n    if (observer) {\n      let domElement = domInfoHelper.get(element);\n      observer.observe(domElement, options);\n    }\n  }\n\n  static disconnect(key: string): void {\n    const observer = this.mutationObservers.get(key)\n    if (observer) {\n      observer.disconnect()\n    }\n  }\n\n  static dispose(key: string): void {\n    this.disconnect(key)\n    this.mutationObservers.delete(key)\n  }\n\n  private static observerCallback(mutations, invoker) {\n    //TODO: serialize a proper object (check resizeObserver.ts for sample)\n    const entriesJson = JSON.stringify(mutations)\n    invoker.invokeMethodAsync('Invoke', entriesJson)\n  }\n}","﻿export { resizeObserver as resize } from './resizeObserver';\nexport { mutationObserver } from './mutationObserver';","﻿import { infoHelper as domInfoHelper} from '../modules/dom/infoHelper';\nimport { boxSize, domRect } from '../modules/dom/types';\n\nclass ResizeObserverEntry {\n  borderBoxSize?: boxSize\n  contentBoxSize?: boxSize\n  contentRect?: domRect\n  target?: Element\n}\n\nexport class resizeObserver {\n\n  static isResizeObserverSupported(): boolean {\n    return \"ResizeObserver\" in window;\n  }\n\n  // @ts-ignore: TS2304: Cannot find name 'ResizeObserver'\n  private static resizeObservers: Map<string, ResizeObserver> = new Map<string, ResizeObserver>();\n\n  static create(key, invoker, isDotNetInvoker: boolean = true ) {\n    // @ts-ignore: TS2304: Cannot find name 'ResizeObserver'\n    let observer;\n        \n    if (isDotNetInvoker) {\n      observer = new ResizeObserver((entries, observer) => resizeObserver.observerCallBack(entries, observer, invoker));\n    } else {\n      observer = new ResizeObserver((entries, observer) => invoker(entries, observer));\n    }\n    resizeObserver.resizeObservers.set(key, observer)\n  }\n\n  static observe(key: string, element) {\n    const observer = resizeObserver.resizeObservers.get(key);\n    if (observer) {\n      let domElement = domInfoHelper.get(element);\n      observer.observe(domElement);\n    }\n  }\n\n  static disconnect(key: string): void {\n    const observer = this.resizeObservers.get(key)\n    if (observer) {\n      observer.disconnect()\n    }\n  }\n\n  static unobserve(key: string, element: Element): void {\n    const observer = this.resizeObservers.get(key)\n\n    if (observer) {\n      let domElement = domInfoHelper.get(element);\n      observer.unobserve(domElement)\n    }\n  }\n\n  static dispose(key: string): void {\n    this.disconnect(key)\n    this.resizeObservers.delete(key)\n  }\n\n  private static observerCallBack(entries, observer, invoker) {\n    if (invoker) {\n      const mappedEntries = new Array<ResizeObserverEntry>()\n      entries.forEach(entry => {        \n        if (entry) {\n          const mEntry = new ResizeObserverEntry()\n          if (entry.borderBoxSize) {\n            mEntry.borderBoxSize = {\n              blockSize: entry.borderBoxSize.blockSize,\n              inlineSize: entry.borderBoxSize.inlineSize\n            }\n          }\n\n          if (entry.contentBoxSize) {\n            mEntry.contentBoxSize = {\n              blockSize: entry.contentBoxSize.blockSize,\n              inlineSize: entry.contentBoxSize.inlineSize\n            }\n          }\n\n          if (entry.contentRect) {\n            mEntry.contentRect = {\n              x: entry.contentRect.x,\n              y: entry.contentRect.y,\n              width: entry.contentRect.width,\n              height: entry.contentRect.height,\n              top: entry.contentRect.top,\n              right: entry.contentRect.right,\n              bottom: entry.contentRect.bottom,\n              left: entry.contentRect.left\n            }\n\n          }\n\n          mEntry.target = entry.target\n          mappedEntries.push(mEntry)\n        }\n      })\n\n      const entriesJson = JSON.stringify(mappedEntries)\n      invoker.invokeMethodAsync('Invoke', entriesJson)\n    }\n  }\n\n}","export { state } from './modules/stateProvider';\nexport * as observable from './ObservableApi/observableApi';\nexport { domInfoHelper, domTypes, domManipulationHelper, eventHelper } from './modules/dom/exports';\nexport { styleHelper } from './modules/styleHelper';\nexport {\n  backtopHelper,\n  iconHelper,\n  inputHelper,\n  mentionsHelper,\n  modalHelper,\n  overlayHelper,\n  tableHelper,\n  uploadHelper\n} from './modules/components/export'\nexport { enableDraggable, disableDraggable, resetModalPosition } from \"./modules/dom/dragHelper\";\n\nexport function log(text) {\n  console.log(text);  \n}\n","﻿import { domInfoHelper, domManipulationHelper } from '../dom/exports'\n\nexport class backtopHelper {\n  static backTop(target: string) {\n    let dom = domInfoHelper.get(target);\n    if (dom) {\n      domManipulationHelper.slideTo(dom.scrollTop);\n    } else {\n      domManipulationHelper.slideTo(0);\n    }\n  }\n}","﻿export { backtopHelper } from './backtopHelper';\nexport { overlayHelper } from './overlayHelper';\nexport { uploadHelper } from './uploadHelper';\nexport { mentionsHelper } from './mentionsHelper';\nexport { modalHelper } from './modalHelper';\nexport { inputHelper } from './inputHelper';\nexport { tableHelper } from './tableHelper';\nexport { iconHelper } from './iconHelper';","﻿export class iconHelper {\n  static createIconFromfontCN(scriptUrl) {\n    if (document.querySelector(`[data-namespace=\"${scriptUrl}\"]`)) {\n      return;\n    }\n    const script = document.createElement('script');\n    script.setAttribute('src', scriptUrl);\n    script.setAttribute('data-namespace', scriptUrl);\n    document.body.appendChild(script);\n  }\n}","﻿import { domInfoHelper } from '../dom/exports'\nimport { state } from '../stateProvider';\n\n\nexport class inputHelper {\n\n  static getTextAreaInfo(element) {\n    var result = {};\n    var dom = domInfoHelper.get(element);\n    if (!dom) return null;\n    result[\"scrollHeight\"] = dom.scrollHeight || 0;\n\n    if (element.currentStyle) {\n      result[\"lineHeight\"] = parseFloat(element.currentStyle[\"line-height\"]);\n      result[\"paddingTop\"] = parseFloat(element.currentStyle[\"padding-top\"]);\n      result[\"paddingBottom\"] = parseFloat(element.currentStyle[\"padding-bottom\"]);\n      result[\"borderBottom\"] = parseFloat(element.currentStyle[\"border-bottom\"]);\n      result[\"borderTop\"] = parseFloat(element.currentStyle[\"border-top\"]);\n    }\n    else if (window.getComputedStyle) {\n      result[\"lineHeight\"] = parseFloat(document.defaultView.getComputedStyle(element, null).getPropertyValue(\"line-height\"));\n      result[\"paddingTop\"] = parseFloat(document.defaultView.getComputedStyle(element, null).getPropertyValue(\"padding-top\"));\n      result[\"paddingBottom\"] = parseFloat(document.defaultView.getComputedStyle(element, null).getPropertyValue(\"padding-bottom\"));\n      result[\"borderBottom\"] = parseFloat(document.defaultView.getComputedStyle(element, null).getPropertyValue(\"border-bottom\"));\n      result[\"borderTop\"] = parseFloat(document.defaultView.getComputedStyle(element, null).getPropertyValue(\"border-top\"));\n    }\n    //Firefox can return this as NaN, so it has to be handled here like that.\n    if (Object.is(NaN, result[\"borderTop\"]))\n      result[\"borderTop\"] = 1;\n    if (Object.is(NaN, result[\"borderBottom\"]))\n      result[\"borderBottom\"] = 1;\n    return result;\n  }\n\n  static registerResizeTextArea(element: HTMLTextAreaElement, minRows: number, maxRows: number, objReference) {\n    if (!objReference) {\n      this.disposeResizeTextArea(element);\n    }\n    else {\n      state.objReferenceDict[element.id] = objReference;\n      state.eventCallbackRegistry[element.id + \"input\"] = function () { inputHelper.resizeTextArea(element, minRows, maxRows); }\n      element.addEventListener(\"input\", state.eventCallbackRegistry[element.id + \"input\"]);\n      return this.getTextAreaInfo(element);\n    }\n  }\n\n  static disposeResizeTextArea(element: HTMLTextAreaElement) {\n    element.removeEventListener(\"input\", state.eventCallbackRegistry[element.id + \"input\"]);\n    state.objReferenceDict[element.id] = null;\n    state.eventCallbackRegistry[element.id + \"input\"] = null;\n  }\n\n  static resizeTextArea(element: HTMLTextAreaElement, minRows: number, maxRows: number) {\n    let dims = this.getTextAreaInfo(element);\n    let rowHeight = dims[\"lineHeight\"];\n    let offsetHeight = dims[\"paddingTop\"] + dims[\"paddingBottom\"] + dims[\"borderTop\"] + dims[\"borderBottom\"];\n    let oldHeight = parseFloat(element.style.height);\n    //use rows attribute to evaluate real scroll height\n    let oldRows = element.rows;\n    element.rows = minRows;\n    element.style.height = 'auto';    \n    \n    var rows = Math.trunc(element.scrollHeight / rowHeight);\n    element.rows = oldRows;\n    rows = Math.max(minRows, rows);    \n    var newHeight = 0;\n    if (rows > maxRows) {\n      rows = maxRows;\n\n      newHeight = (rows * rowHeight + offsetHeight);\n      element.style.height = newHeight + \"px\";\n      element.style.overflowY = \"visible\";\n    }\n    else {\n      newHeight = rows * rowHeight + offsetHeight;\n      element.style.height = newHeight + \"px\";\n      element.style.overflowY = \"hidden\";\n    }\n    if (oldHeight !== newHeight) {\n      let textAreaObj = state.objReferenceDict[element.id];\n      textAreaObj.invokeMethodAsync(\"ChangeSizeAsyncJs\", element.scrollWidth, newHeight);\n    }\n  }\n\n  static setSelectionStart(element, position: number) {\n    if (position >= 0) {\n      let dom: HTMLInputElement = domInfoHelper.get(element);\n      if (dom) {\n        if (position <= dom.value.length) {\n          dom.selectionStart = position;\n          dom.selectionEnd = position;\n        }\n      }\n    }\n  }\n\n}","﻿import { state } from \"../stateProvider\";\n\nexport class mentionsHelper {\n\n  static getCursorXY(element, objReference) {\n    state.objReferenceDict[\"mentions\"] = objReference;\n    window.addEventListener(\"click\", this.mentionsOnWindowClick);\n\n    const offset = this.getOffset(element);\n\n    return [offset.left, offset.top + offset.height + 14];\n  }\n\n  private static getOffset(elem) {\n    return (new InputCaret(elem)).getOffset();\n  }\n\n  private static mentionsOnWindowClick(e) {\n    let mentionsObj = state.objReferenceDict[\"mentions\"];\n    if (mentionsObj) {\n      mentionsObj.invokeMethodAsync(\"CloseMentionsDropDown\");\n    } else {\n      window.removeEventListener(\"click\", this.mentionsOnWindowClick);\n    }\n  }\n\n}\n\nclass InputCaret {\n  domInputor: any;\n\n  constructor(inputor) {\n    this.domInputor = inputor;\n  }\n\n  getPos = function () {\n    return this.domInputor.selectionStart;\n  };\n\n  getPosition = function (pos) {\n    var domInputor, end_range, format, html, mirror, start_range;\n    domInputor = this.domInputor;\n\n    format = function (value) {\n      value = value.replace(/<|>|`|\"|&/g, '?').replace(/\\r\\n|\\r|\\n/g, \"<br/>\");\n      if (/firefox/i.test(navigator.userAgent)) {\n        value = value.replace(/\\s/g, '&nbsp;');\n      }\n      return value;\n    };\n    if (!pos) {\n      pos = this.getPos();\n    }\n    let inputorValue = domInputor.value;\n    start_range = inputorValue.slice(0, pos);\n    end_range = inputorValue.slice(pos);\n    html = \"<span style='position: relative; display: inline;'>\" + format(start_range) + \"</span>\";\n    html += \"<span id='caret' style='position: relative; display: inline;'>|</span>\";\n    html += \"<span style='position: relative; display: inline;'>\" + format(end_range) + \"</span>\";\n    mirror = new Mirror(domInputor);\n    return mirror.create(html).rect();\n  };\n\n  getOffset = function (pos = null) {\n    var offset, position, domInputor;\n    domInputor = this.domInputor;\n\n    var rect = domInputor.getBoundingClientRect();\n\n    offset = {\n      left: rect.left,\n      top: rect.top\n    };\n\n    position = this.getPosition(pos);\n    return offset = {\n      left: offset.left + position.left - domInputor.scrollLeft,\n      top: offset.top + position.top - domInputor.scrollTop,\n      height: position.height\n    };\n  };\n\n}\n\nclass Mirror {\n  domInputor: any;\n  css_attr: any;\n  constructor(inputor) {\n    this.domInputor = inputor;\n    this.css_attr = [];\n  }\n\n  create = function (html) {\n    this.$mirror = document.createElement(\"div\");\n    //TODO: hard coded reference, try to make it more relative\n    (<any>window).AntDesign.interop.styleHelper.css(this.$mirror, this.mirrorCss());\n\n    this.$mirror.innerHTML = html;\n    this.domInputor.parentElement.append(this.$mirror);\n\n    return this;\n  };\n\n  mirrorCss = function () {\n    var css, _this = this;\n    css = {\n      position: 'absolute',\n      left: -9999,\n      top: 0,\n      zIndex: -20000\n    };\n\n    this.css_attr.push('width');\n\n    this.css_attr.forEach((p) => {\n      return css[p] = _this.domInputor.style[p]//_this.$inputor.css(p);\n    })\n\n    return css;\n  };\n\n  rect = function () {\n    var flag, pos, rect;\n    flag = this.$mirror.querySelector(\"#caret\");\n    var oRect = flag.getBoundingClientRect();\n\n    pos = {\n      left: flag.offsetLeft,\n      top: flag.offsetTop\n    }; //$flag.position();\n\n    rect = {\n      left: pos.left,\n      top: pos.top,\n      height: oRect.height\n    };\n\n    this.$mirror.parentElement.removeChild(this.$mirror)\n    return rect;\n  };\n\n}","﻿import { domInfoHelper } from '../dom/exports'\n\nexport class modalHelper {\n  static focusDialog(selector: string, count: number = 0) {\n    let ele = <HTMLElement>document.querySelector(selector);\n    if (ele) {\n      if (ele.hasAttribute(\"disabled\")) {\n        let htmlElement = <HTMLElement>document.activeElement;\n        htmlElement?.blur();\n      } else {\n        setTimeout(() => {\n          ele.focus();\n          let curId = \"#\" + domInfoHelper.getActiveElement();\n          if (curId !== selector) {\n            if (count < 10) {\n              this.focusDialog(selector, count + 1);\n            }\n          }\n        }, 10);\n      }\n    }\n  }\n\n  static destroyAllDialog() {\n    document.querySelectorAll('.ant-modal-root')\n      .forEach(e => document.body.removeChild(e.parentNode));\n  }\n}","﻿import { domInfoHelper, domTypes } from '../dom/exports'\nimport { resize } from '../../ObservableApi/observableApi';\nimport { mutationObserver as mutation } from '../../ObservableApi/mutationObserver';\n\n//Make sure the enum is identical as C# AntDesign.Placement enum\nexport enum Placement {\n  TopLeft       = 0,\n  TopCenter     = 1,\n  Top           = 2,\n  TopRight      = 3,\n  Left          = 4,\n  LeftTop       = 5,\n  LeftBottom    = 6,\n  Right         = 7,\n  RightTop      = 8,\n  RightBottom   = 9,\n  BottomLeft    = 10,\n  BottomCenter  = 11,\n  Bottom        = 12,\n  BottomRight   = 13\n}\n\n//Make sure the enum is identical as C# AntDesign.TriggerBoundyAdjustMode enum\nexport enum TriggerBoundyAdjustMode {\n  None     = 0,\n  InView   = 1,\n  InScroll = 2\n}\n\ntype verticalPosition = {\n  top?: number,\n  bottom?: number\n}\n\ntype horizontalPosition = {\n  left?: number,\n  right?: number\n}\n\nexport type overlayConstraints = {\n  verticalOffset: number,\n  horizontalOffset: number,\n  arrowPointAtCenter: boolean\n}\nexport type coordinates = {\n  top?: number,\n  bottom?: number,\n  left?: number,\n  right?: number\n}\n\n\nexport type overlayPosition = {\n  top?: number,\n  bottom?: number,\n  left?: number,\n  right?: number,\n  zIndex: number,\n  placement?: Placement,\n}\n\nexport class Overlay {\n    private static appliedStylePositionMap: Map<Placement,\n        { horizontal: \"left\" | \"right\", vertical: \"top\" | \"bottom\", class: string }> =\n    new Map([\n      [Placement.TopLeft,       { horizontal: \"left\", vertical: \"bottom\", class: \"topLeft\"  }],\n      [Placement.TopCenter,     { horizontal: \"left\", vertical: \"bottom\", class: \"topCenter\" }],\n      [Placement.Top,           { horizontal: \"left\", vertical: \"bottom\", class: \"top\" }],\n      [Placement.TopRight,      { horizontal: \"right\", vertical: \"bottom\", class: \"topRight\" }],\n      [Placement.Left,          { horizontal: \"right\", vertical: \"top\", class: \"left\" }],\n      [Placement.LeftTop,       { horizontal: \"right\", vertical: \"top\", class: \"leftTop\" }],\n      [Placement.LeftBottom,    { horizontal: \"right\", vertical: \"bottom\", class: \"leftBottom\" }],\n      [Placement.Right,         { horizontal: \"left\", vertical: \"top\", class: \"right\" }],\n      [Placement.RightTop,      { horizontal: \"left\", vertical: \"top\", class: \"rightTop\" }],\n      [Placement.RightBottom,   { horizontal: \"left\", vertical: \"bottom\", class: \"rightBottom\" }],\n      [Placement.BottomLeft,    { horizontal: \"left\", vertical: \"top\", class: \"bottomLeft\" }],\n      [Placement.BottomCenter,  { horizontal: \"left\", vertical: \"top\", class: \"bottomCenter\" }],\n      [Placement.Bottom,        { horizontal: \"left\", vertical: \"top\", class: \"bottom\" }],\n      [Placement.BottomRight,   { horizontal: \"right\", vertical: \"top\", class: \"bottomRight\" }],\n    ]);\n\n  private static reverseVerticalPlacementMap: Map<Placement, Function> =\n    new Map([\n      [Placement.TopLeft,       (position: string) => Placement.BottomLeft],\n      [Placement.TopCenter,     (position: string) => Placement.BottomCenter],\n      [Placement.Top,           (position: string) => Placement.Bottom],\n      [Placement.TopRight,      (position: string) => Placement.BottomRight],\n      [Placement.Left,          (position: string) => position === \"top\" ? Placement.LeftBottom : Placement.LeftTop],\n      [Placement.LeftTop,       (position: string) => Placement.LeftBottom],\n      [Placement.LeftBottom,    (position: string) => Placement.LeftTop],\n      [Placement.Right,         (position: string) => position === \"top\" ? Placement.RightBottom : Placement.RightTop],\n      [Placement.RightTop,      (position: string) => Placement.RightBottom],\n      [Placement.RightBottom,   (position: string) => Placement.RightTop],\n      [Placement.BottomLeft,    (position: string) => Placement.TopLeft],\n      [Placement.BottomCenter,  (position: string) => Placement.TopCenter],\n      [Placement.Bottom,        (position: string) => Placement.Top],\n      [Placement.BottomRight,   (position: string) => Placement.TopRight]\n    ]);\n    \n  private static reverseHorizontalPlacementMap: Map<Placement, Function> =\n    new Map([\n      [Placement.TopLeft,       (position: string) => Placement.TopRight],\n      [Placement.TopCenter,     (position: string) => position === \"left\" ? Placement.TopRight : Placement.TopLeft],\n      [Placement.Top,     (position: string) => position === \"left\" ? Placement.TopRight : Placement.TopLeft],\n      [Placement.TopRight,      (position: string) => Placement.TopLeft],\n      [Placement.Left,          (position: string) => Placement.Right],\n      [Placement.LeftTop,       (position: string) => Placement.RightTop],\n      [Placement.LeftBottom,    (position: string) => Placement.RightBottom],\n      [Placement.Right,         (position: string) => Placement.Left],\n      [Placement.RightTop,      (position: string) => Placement.LeftBottom],\n      [Placement.RightBottom,   (position: string) => Placement.LeftTop],\n      [Placement.BottomLeft,    (position: string) => Placement.BottomRight],\n      [Placement.BottomCenter,  (position: string) => position === \"left\" ? Placement.BottomRight : Placement.BottomLeft],\n      [Placement.Bottom,        (position: string) => position === \"left\" ? Placement.BottomRight : Placement.BottomLeft],\n      [Placement.BottomRight,   (position: string) => Placement.BottomLeft]\n    ]);    \n    \n  private static arrowCenterPlacementMatch: Map<Placement, Placement> =\n    new Map([\n      [Placement.TopLeft,       Placement.Top],\n      [Placement.TopCenter,     Placement.TopCenter],\n      [Placement.Top,           Placement.Top],\n      [Placement.TopRight,      Placement.Top],\n      [Placement.Left,          Placement.Left],\n      [Placement.LeftTop,       Placement.Left],\n      [Placement.LeftBottom,    Placement.Left],\n      [Placement.Right,         Placement.Right],\n      [Placement.RightTop,      Placement.Right],\n      [Placement.RightBottom,   Placement.Right],\n      [Placement.BottomLeft,    Placement.Bottom],\n      [Placement.BottomCenter,  Placement.BottomCenter],\n      [Placement.Bottom,        Placement.Bottom],\n      [Placement.BottomRight,   Placement.Bottom]\n    ]);   \n    \n  private blazorId: string;\n  public overlay: HTMLDivElement;\n  private container: HTMLElement;\n  private trigger: HTMLElement;\n\n  private overlayInfo: domTypes.domInfo;\n  private containerInfo: domTypes.domInfo;\n  private triggerInfo: domTypes.domInfo;\n  \n  private containerBoundarySize: coordinates;\n  private bodyBoundarySize: coordinates;\n  \n  private placement: Placement;\n  private recentPlacement: Placement;\n  private initialPlacement?: Placement;\n\n  private triggerPrefixCls: string; \n\n  private boundyAdjustMode: TriggerBoundyAdjustMode\n  public position: overlayPosition;\n  public sanitizedPosition: overlayPosition;\n  \n  private overlayPreset: domTypes.position;\n\n  private verticalCalculation:\n    (triggerPosition: number, triggerHeight: number, container: domTypes.domInfo,\n    trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints)\n      => verticalPosition;\n\n  private horizontalCalculation:\n    (triggerPosition: number, triggerWidth: number, container: domTypes.domInfo,\n    trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints)\n        => horizontalPosition;\n\n  private overlayConstraints: overlayConstraints; \n  private duringInit = true;\n  private selectedVerticalPosition: \"top\" | \"bottom\";\n  private selectedHorizontalPosition: \"left\" | \"right\";\n  private calculationsToPerform: Set<\"horizontal\"|\"vertical\">;\n\n  private triggerPosition: coordinates & { absoluteTop?: number, absoluteLeft?: number, height?: number, width?: number } = { };  \n\n  private isContainerBody: boolean;\n  private isContainerOverBody = false;\n  private isTriggerFixed: boolean; //refers to trigger or any of its parent having \"position:fixed\"\n  private lastScrollPosition: number; //used only if isTriggerFixed === true\n\n  private scrollbarSize: {\n    horizontalHeight: number,\n    verticalWidth: number\n  }  \n\n  constructor(blazorId: string,\n    overlay: HTMLDivElement, container: HTMLElement, trigger: HTMLElement, placement: Placement, \n    triggerBoundyAdjustMode: TriggerBoundyAdjustMode, triggerIsWrappedInDiv: boolean, triggerPrefixCls: string,\n    overlayConstraints: overlayConstraints) {\n    this.blazorId = blazorId;\n    this.overlay = overlay;  \n    //containerInfo & scrollbars have to be obtained here, because after\n    //removal of classes, the overlay goes to left: -9999 what causes artificial \n    //scrollbars and viewport dimensions are changing\n    this.containerInfo = domInfoHelper.getInfo(container);\n    this.container = container;\n    this.isContainerBody = container === document.body;\n    this.calculateScrollBarSizes()\n    if (!this.isContainerBody) {\n      this.isContainerOverBody = domInfoHelper.findAncestorWithZIndex(this.container) > 0;\n    }\n\n    this.overlay.style.cssText = this.overlay.style.cssText.replace(\"display: none;\", \"\");\n    this.overlay.style.top = \"0px\"; //reset to prevent scrollbars if do not exist\n    this.removeHiddenClass()\n\n    //The trigger is actually wrapping div, which can have its own dimensions (coming from styles).\n    //So, first valid HTML element is picked and if there is none, the wrapping div is set as trigger.\n    //Triggers are always wrapped in div if the <ChildElement> instead of <Unbound> is used.\n    this.trigger = Overlay.getFirstValidChild(trigger, triggerIsWrappedInDiv);\n    this.triggerPrefixCls = triggerPrefixCls;\n    if (overlayConstraints.arrowPointAtCenter){      \n      this.placement = Overlay.arrowCenterPlacementMatch.get(placement);\n    } else {\n      this.placement = placement;\n    }\n    this.initialPlacement = this.placement;\n    this.boundyAdjustMode = triggerBoundyAdjustMode;    \n    this.overlayConstraints = overlayConstraints;\n\n    this.position = { zIndex: 0 };\n    this.selectedHorizontalPosition = Overlay.appliedStylePositionMap.get(this.placement).horizontal;\n    this.selectedVerticalPosition = Overlay.appliedStylePositionMap.get(this.placement).vertical;\n\n    this.verticalCalculation = Overlay.setVerticalCalculation(this.placement, this.selectedVerticalPosition);\n    this.horizontalCalculation = Overlay.setHorizontalCalculation(this.placement, this.selectedHorizontalPosition);\n    this.isTriggerFixed = domInfoHelper.isFixedPosition(this.trigger);\n    this.observe();\n  }\n\n  static getFirstValidChild(element: HTMLElement, triggerIsWrappedInDiv: boolean): HTMLElement {\n    if (triggerIsWrappedInDiv)\n    {      \n      for(let i = 0; i < element.childNodes.length; i++) {\n        const childElement = element.childNodes[i] as HTMLElement;\n        if (childElement.innerHTML)\n          return childElement;\n      }\n    }\n    return element\n  }\n\n  static setVerticalCalculation(placement: Placement, position: \"top\" | \"bottom\") {\n    if (position === \"top\") {\n      switch (placement) {\n        case Placement.LeftTop:\n        case Placement.RightTop:          \n          return function(triggerTop: number, triggerHeight: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints) {               \n            return { \n              top: triggerTop,\n              bottom: Overlay.reversePositionValue(triggerTop, container.scrollHeight, overlayHeight) \n            };              \n          }; \n        case Placement.BottomLeft:\n        case Placement.BottomCenter:\n        case Placement.Bottom:\n        case Placement.BottomRight:\n          return function(triggerTop: number, triggerHeight: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints) { \n            const position: verticalPosition = {\n              top: triggerTop + triggerHeight + constraints.verticalOffset,\n            };\n            position.bottom = Overlay.reversePositionValue(position.top, container.scrollHeight, overlayHeight)\n            return position;\n          }; \n        case Placement.Left:\n        case Placement.Right:\n          return function(triggerTop: number, triggerHeight: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints) {     \n            const position: verticalPosition = { \n              top: triggerTop + (triggerHeight / 2) - (overlayHeight / 2)\n            };\n            position.bottom = Overlay.reversePositionValue(position.top, container.scrollHeight, overlayHeight)\n            return position;\n          }; \n      }\n    }    \n    if (position === \"bottom\") {\n      switch (placement) {\n        case Placement.TopLeft:\n        case Placement.TopCenter:\n        case Placement.Top:\n        case Placement.TopRight:\n          return function(triggerBottom: number, triggerHeight: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints) { \n            const position: verticalPosition = { \n              bottom: triggerBottom + triggerHeight + constraints.verticalOffset,\n            };\n            position.top = Overlay.reversePositionValue(position.bottom, container.scrollHeight, overlayHeight);\n            return position;\n          };           \n        case Placement.LeftBottom:\n        case Placement.RightBottom:\n          return function(triggerBottom: number, triggerHeight: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayHeight: number, constraints: overlayConstraints) {  \n            const position: verticalPosition = { \n              bottom: triggerBottom,\n              top: Overlay.reversePositionValue(triggerBottom, container.scrollHeight, overlayHeight)\n            };            \n            return position;                               \n          };   \n      }\n    }\n    //fallback - should not happen, but to avoid crashing scenarios, revert to BottomLeft\n    console.log(\"Error: setVerticalCalculation did not match, nothing selected!!! Fallback.\", placement, position);\n    return Overlay.setVerticalCalculation(Placement.BottomLeft, \"top\");\n  }\n\n  static setHorizontalCalculation(placement: Placement, position: \"left\" | \"right\") {\n    if (position === \"left\") {\n      switch (placement) {\n        case Placement.TopLeft:\n        case Placement.BottomLeft:\n          return function(triggerLeft: number, triggerWidth: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints) {        \n            return { \n              left: triggerLeft,\n              right: Overlay.reversePositionValue(triggerLeft, container.scrollWidth, overlayWidth)\n            };              \n          }; \n        case Placement.Right:\n        case Placement.RightTop:\n        case Placement.RightBottom:\n          return function(triggerLeft: number, triggerWidth: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints) {        \n            const position: horizontalPosition = {\n              left: triggerLeft + triggerWidth + constraints.horizontalOffset\n            };\n            position.right = Overlay.reversePositionValue(position.left, container.scrollWidth, overlayWidth)\n            return position;\n          };\n        case Placement.TopCenter:\n        case Placement.Top:\n        case Placement.BottomCenter:\n        case Placement.Bottom:\n          return function(triggerLeft: number, triggerWidth: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints) {        \n            const position: horizontalPosition = {\n              left: triggerLeft + (triggerWidth / 2) - (overlayWidth / 2)\n            };\n            position.right = Overlay.reversePositionValue(position.left, container.scrollWidth, overlayWidth)\n            return position;\n          };\n      }\n    }\n    if (position === \"right\") {\n      switch (placement) {\n        case Placement.TopRight:\n        case Placement.BottomRight:\n          return function(triggerRight: number, triggerWidth: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints) {        \n            let position: horizontalPosition = {\n              right: triggerRight,\n              left: Overlay.reversePositionValue(triggerRight, container.scrollWidth, overlayWidth)\n            };            \n            return position;\n          };\n        case Placement.Left:\n        case Placement.LeftTop:\n        case Placement.LeftBottom:\n          return function(triggerRight: number, triggerWidth: number, container: domTypes.domInfo, trigger: domTypes.domInfo, overlayWidth: number, constraints: overlayConstraints) {\n            const position: horizontalPosition = {\n              right: triggerRight + triggerWidth + constraints.horizontalOffset\n            };\n            position.left = Overlay.reversePositionValue(position.right, container.scrollWidth, overlayWidth)\n            return position;\n          };          \n      }      \n    }\n    //fallback - should not happen, but to avoid crashing scenarios, revert to BottomLeft\n    console.log(\"Error: setHorizontalCalculation did not match, nothing selected!!! Fallback.\", placement, position);\n    return Overlay.setVerticalCalculation(Placement.BottomLeft, \"top\");    \n  }\n\n  /**\n   * Calculates reversed position. So for given left will return right,\n   * for top => bottom, etc.\n   * @param the value that needs to be reversed (left in scenario: left => right)\n   * @param for horizontal (left, right) container width & for vertical (top, bottom) container height\n   * @param for horizontal (left, right) overlay width & for vertical (top, bottom) overlay height\n   * @returns number\n   */\n  static reversePositionValue(position: number, containerDimension: number, overlayDimension: number) {    \n    return containerDimension - position - overlayDimension;\n  }\n\n  private removeHiddenClass() {    \n    let end = this.overlay.className.indexOf(\"-hidden\");\n    let start = this.overlay.className.lastIndexOf(\" \", end)\n    if (start >= 0) {\n      let className = this.overlay.className.substr(start + 1, end);\n      if (className !== \"\") {\n        this.overlay.classList.remove(className);\n      }\n    }\n  }\n\n  private calculateScrollBarSizes() {\n    if (this.isContainerBody) {\n      this.scrollbarSize = { \n        horizontalHeight: window.innerHeight - document.documentElement.clientHeight,\n        verticalWidth: window.innerWidth - document.documentElement.clientWidth\n      }\n    } \n    else {\n      this.scrollbarSize = { \n        horizontalHeight: this.container.offsetHeight - this.container.clientHeight, \n        verticalWidth: this.container.offsetWidth - this.container.clientWidth \n      }\n    }\n  }\n\n  private observe() {\n    resize.create(`container-${this.blazorId}`, this.resizing.bind(this), false);\n    resize.observe(`container-${this.blazorId}`, this.container);    \n    resize.observe(`container-${this.blazorId}`, this.trigger);    \n    mutation.create(`trigger-${this.blazorId}`, this.mutating.bind(this), false);\n    mutation.observe(`trigger-${this.blazorId}`, this.trigger, {\n      attributes: true,\n      characterData: false,\n      childList: false,\n      subtree: false,\n      attributeOldValue: false,\n      characterDataOldValue: false\n    });\n    \n    if (this.isContainerBody) {\n      window.addEventListener(\"scroll\", this.onScroll.bind(this));\n    }\n    else {\n      this.container.addEventListener(\"scroll\", this.onScroll.bind(this));\n    }\n  }  \n\n  private onScroll() {\n    if (this.isTriggerFixed) {\n      if (this.lastScrollPosition !== window.pageYOffset) {      \n        const diff = window.pageYOffset - this.lastScrollPosition; //positive -> down, negative -> up        \n        this.position.top += diff;\n        this.position.bottom = Overlay.reversePositionValue(this.position.top, this.containerInfo.scrollHeight, this.overlayInfo.clientHeight);      \n        if (this.selectedVerticalPosition === \"top\") {        \n          this.sanitizedPosition.top = this.position.top;\n          this.overlay.style.top = this.sanitizedPosition.top + \"px\";        \n        } else {\n          this.sanitizedPosition.bottom = this.getAdjustedBottom();\n          this.overlay.style.bottom = this.sanitizedPosition.bottom + \"px\";\n        }\n        this.lastScrollPosition = window.pageYOffset;\n      }\n    } else {\n      //Commented out code is a non-optimized calculation only if overlay stops fitting during scroll\n      //It misses active check for initialPlacement being different to current placement\n      // this.getKeyElementDimensions(false);\n      // this.containerBoundarySize = this.getContainerBoundarySize();\n      // if (!this.overlayFitsContainer(\"horizontal\", this.position.left, this.position.right)\n      //   || !this.overlayFitsContainer(\"vertical\", this.position.top, this.position.bottom)) {    \n      //     this.calculatePosition(true, false, this.overlayPreset)\n      // }    \n      this.calculatePosition(true, false, this.overlayPreset);\n    }\n  }\n\n  private resizing(entries, observer) {\n    //prevents from recalculation right on the spot during constructor run\n    if (this.duringInit) { \n      this.duringInit = false;\n      return;\n    }\n    this.calculatePosition(true, false, this.overlayPreset);\n  }\n\n  private lastStyleMutation = \"\";\n\n  /**\n   * Mutation observer will fire whenever trigger style changes. This is first and foremost\n   * to monitor position/size changes, so overlay can adjust itself to the new position.\n   * @param mutations \n   * @returns \n   */\n  private mutating(mutations) {\n    if (this.duringInit) { \n      this.duringInit = false;\n      return;\n    }    \n    if (this.lastStyleMutation !== this.trigger.style.cssText) {\n      this.lastStyleMutation = this.trigger.style.cssText;\n      this.calculatePosition(true, false, this.overlayPreset);\n    }\n    \n  }\n\n  public dispose(): void {    \n    resize.dispose(`container-${this.blazorId}`);\n    mutation.dispose(`trigger-${this.blazorId}`);\n    if (this.container.contains(this.overlay)) {\n      this.container.removeChild(this.overlay);\n    }\n\n    if (this.isContainerBody) {      \n      window.removeEventListener(\"scroll\", this.onScroll);\n    }\n    else {\n      this.container.removeEventListener(\"scroll\", this.onScroll);\n    }\n  }\n\n  public calculatePosition(applyLocation: boolean, firstTime = false, overlayPreset?: domTypes.position): overlayPosition {        \n    //check if hidden, if yes, no need to recalculate (only if not first time)\n    if (!firstTime && !this.overlay.offsetParent) {      \n      return;\n    }\n    //trigger no longer visible, hide\n    if (!overlayPreset && !this.trigger.offsetParent) {      \n      if (!this.overlay.classList.contains(this.triggerPrefixCls + \"-hidden\")) {\n        this.overlay.classList.add(this.triggerPrefixCls + \"-hidden\");\n      }\n      return this.position;\n    }\n    this.lastScrollPosition = window.pageYOffset;\n    this.recentPlacement = this.placement;\n    this.overlayPreset = overlayPreset;\n\n    this.getKeyElementDimensions(firstTime);\n\n    this.restoreInitialPlacement();\n\n    //add a very basic check - if overlay width exceeds container width, left defaults to 0     \n    this.calculationsToPerform = this.getNominalPositions();\n    if (this.calculationsToPerform.size > 0) {\n      this.adjustToContainerBoundaries();\n    }\n\n    this.sanitizeCalculatedPositions();    \n    //first positioning is applied by blazor - without it, a flicker is visible\n    if (applyLocation) {\n      this.applyLocation();\n    }    \n    return this.sanitizedPosition;\n  }\n\n  /**\n   * All variants of positions are stored during calculations, but only key positions are \n   * returned (so only left or right and only top or bottom).\n   * Also, bottom & right positions need to be recalculated, due to the fact that during \n   * calculations:\n   *  - bottom is represented as a value counting from top \n   *  - right is represented as a value counting from left\n   * Browsers use different reference for bottom & right.\n   */\n  private sanitizeCalculatedPositions() {\n    this.sanitizedPosition = { ...this.position};\n    this.sanitizedPosition.zIndex = domInfoHelper.getMaxZIndex();\n    this.sanitizedPosition.placement = this.placement;    \n    if (this.selectedHorizontalPosition === \"left\") {\n      this.sanitizedPosition.right = null;\n    }\n    else {\n      this.sanitizedPosition.left = null;\n      this.sanitizedPosition.right = this.getAdjustedRight();\n    }\n\n    if (this.selectedVerticalPosition === \"top\") {\n      this.sanitizedPosition.bottom = null;\n    }\n    else {\n      this.sanitizedPosition.top = null;\n      this.sanitizedPosition.bottom = this.getAdjustedBottom();\n    }\n  }\n\n  /**\n   * Gets first calculations of the overlay. For each direction, there is a single scenario\n   * when it is immediately known that no further calculation is needed:\n   * - for vertical direction - when overlay's height is larger than container vertical boundaries\n   * - for vertical direction - when overlay's width is larger than container horizontal boundaries\n   * These scenarios are ignored, when boundyAdjustMode === TriggerBoundyAdjustMode.None\n   * @returns collection containing directions that will be calculable (not final)\n   */\n  private getNominalPositions(): Set<\"horizontal\"|\"vertical\"> {\n    this.containerBoundarySize = this.getContainerBoundarySize();\n    const height = this.containerBoundarySize.bottom - this.containerBoundarySize.top;\n    const width = this.containerBoundarySize.right - this.containerBoundarySize.left;\n    const directionsToCalculate = new Set<\"horizontal\"|\"vertical\">();\n\n    if (this.boundyAdjustMode != TriggerBoundyAdjustMode.None && width < this.overlayInfo.clientWidth && this.isContainerBody) {\n      if (this.selectedHorizontalPosition === \"left\") {\n        this.position.left = 0;\n      } else {\n        this.position.right = 0;\n      }\n    } else {\n      const horizontalPosition = this.getHorizontalPosition();\n      this.position.left = horizontalPosition.left;\n      this.position.right = horizontalPosition.right;\n      directionsToCalculate.add(\"horizontal\");\n    }\n    //same for height exceeding container height - top defaults to 0   \n    if (this.boundyAdjustMode != TriggerBoundyAdjustMode.None && height < this.overlayInfo.clientHeight && this.isContainerBody) {      \n      if (this.selectedVerticalPosition === \"top\") {\n        this.position.top = 0;\n      } else {\n        this.position.bottom = 0;\n      }\n    } else {\n      \n      const verticalPosition = this.getVerticalPosition();\n      this.position.top = verticalPosition.top;\n      this.position.bottom = verticalPosition.bottom;      \n      directionsToCalculate.add(\"vertical\");\n    }\n    return directionsToCalculate;\n  }\n\n  /**\n   * Restore initial placement (and following connected variables & functions) on calculation.\n   * This never kicks in on first calculation. This is done because the overlay should always\n   * try to position itself to the initial placement. So on every recalculation initial settings\n   * (used during object creation) are reloaded.\n   */\n  private restoreInitialPlacement() {\n    if (this.placement !== this.initialPlacement) {\n      this.placement = this.initialPlacement;\n      this.selectedHorizontalPosition = Overlay.appliedStylePositionMap.get(this.placement).horizontal;\n      this.selectedVerticalPosition = Overlay.appliedStylePositionMap.get(this.placement).vertical;\n      this.verticalCalculation = Overlay.setVerticalCalculation(this.placement, this.selectedVerticalPosition);\n      this.horizontalCalculation = Overlay.setHorizontalCalculation(this.placement, this.selectedHorizontalPosition);\n    }\n  }\n\n  /**\n   * Very basic logging, useful during debugging.\n   * @param extraMessage \n   */\n  /* istanbul ignore next */\n  private logToConsole(extraMessage = \"\") {\n    console.log(extraMessage + \" Overlay position:\", this.position,\n      \"Input\",\n      { \n        blazorId: this.blazorId,        \n        container: {\n          info: this.containerInfo,\n          parentInfo: {\n            clientHeight: this.container.parentElement.clientHeight,\n            clientWidth: this.container.parentElement.clientWidth,\n            scrollLeft: this.container.parentElement.scrollLeft,\n            scrollTop: this.container.parentElement.scrollTop\n          },\n          containerId: this.container.id,        \n          containerBoundarySize: this.containerBoundarySize,\n        },\n        trigger: { \n          absoluteTop: this.triggerInfo.absoluteTop,\n          absoluteLeft: this.triggerInfo.absoluteLeft,\n          clientHeight: this.triggerInfo.clientHeight,\n          clientWidth: this.triggerInfo.clientWidth,\n          offsetHeight: this.triggerInfo.offsetHeight,\n          offsetWidth: this.triggerInfo.offsetWidth,\n          boundyAdjustMode: this.boundyAdjustMode,\n          //triggerType: this.triggerType,\n          triggerHtml: this.trigger.outerHTML,\n          triggerPrefixCls: this.triggerPrefixCls\n        },\n        overlay: { \n          clientHeight: this.overlayInfo.clientHeight,\n          clientWidth: this.overlayInfo.clientWidth,\n          offsetHeight: this.overlayInfo.offsetHeight,\n          offsetWidth: this.overlayInfo.offsetWidth,\n          class: this.overlay.className,\n          appliedCssPosition: {\n            overlay_style_top: this.overlay.style.top,\n            overlay_style_bottom: this.overlay.style.bottom,\n            overlay_style_left: this.overlay.style.left,\n            overlay_style_right: this.overlay.style.right\n          }\n        },\n        window: {\n          innerHeight: window.innerHeight,\n          innerWidth: window.innerWidth,\n          pageXOffset: window.pageXOffset,\n          pageYOffset: window.pageYOffset,\n        },        \n        documentElement: {\n          clientHeight: document.documentElement.clientHeight,\n          clientWidth: document.documentElement.clientWidth,\n          containerIsBody: this.isContainerBody,\n        },\n        scrollbars: this.scrollbarSize,\n        overlayPreset: this.overlayPreset,\n        overlayConstraints: this.overlayConstraints,\n        position: this.position,           \n        sanitizedPosition: this.sanitizedPosition,\n        placment: {\n         initialPlacement: this.initialPlacement,\n         recentPlacement: this.recentPlacement,\n         placement: this.placement,\n         selectedHorizontalPosition: this.selectedHorizontalPosition,\n         selectedVerticalPosition: this.selectedVerticalPosition\n        }\n      }\n    );    \n  }\n\n  /**\n   * Right in the class is calculated with assumption that it is just reversed Left. \n   * This works well for containers that are not body. When in body, then different Right \n   * calculation is executed. Example:\n   * In a document of width of 5000px, the first Left = 0 and the first Right = 0 as well \n   * (and respectively, max Left = 5000 and max Right = 5000). However, browsers are behaving \n   * differently. Left indeed is 0 until the document width (5000). Right however is different. \n   * Right = 0 means the point of original viewport most Right. So, if you viewport is 1000px \n   * wide, Right = 0 will mean same as Left = 1000. So to reach Left = 5000, Right has to \n   * be equal to -4000. \n   * @returns number - right position\n   */\n  private getAdjustedRight(): number {    \n    if (this.isContainerBody) {\n      return this.position.right - (this.containerInfo.scrollWidth - window.innerWidth)\n        - this.scrollbarSize.verticalWidth;\n    }\n    return this.position.right;    \n  }\n\n  /**\n   * Bottom in the class is calculated with assumption that it is just reversed Top. \n   * This works well for containers that are not body. When in body, then different Bottom\n   * calculation is executed. Example:\n   * In a document of height of 5000px, the first Top = 0 and the first Bottom = 0 as well \n   * (and respectively, max Top = 5000 and max Bottom = 5000). However, browsers are behaving \n   * differently. Top indeed is 0 until the document height (5000). Bottom however is different. \n   * Bottom = 0 means the point of original viewport most bottom. So, if you viewport is 1000px \n   * in height, Bottom = 0 will mean same as Top = 1000. So to reach Top = 5000, Bottom has to \n   * be equal to -4000. \n   * @returns number - bottom position\n   */\n  private getAdjustedBottom(): number {    \n    if (this.isContainerBody) {\n      return this.position.bottom - (this.containerInfo.scrollHeight - window.innerHeight)\n        - this.scrollbarSize.horizontalHeight;\n    }\n    return this.position.bottom;\n  }\n\n  private applyLocation() {\n    if (this.selectedHorizontalPosition === \"left\") {\n      this.overlay.style.left = this.sanitizedPosition.left + \"px\";\n      this.overlay.style.right = \"unset\";\n    } else {\n      this.overlay.style.right = this.sanitizedPosition.right + \"px\";\n      this.overlay.style.left = \"unset\";\n    }\n\n    if (this.selectedVerticalPosition === \"top\") {\n      this.overlay.style.top = this.sanitizedPosition.top + \"px\";\n      this.overlay.style.bottom = \"unset\";\n    } else {\n      this.overlay.style.bottom = this.sanitizedPosition.bottom + \"px\";\n      this.overlay.style.top = \"unset\";\n    }\n\n    this.applyPlacement();\n  }\n\n  private applyPlacement() {\n    if (this.recentPlacement !== this.placement) {\n      let currentPlacement: string;\n      const stringMach = `${this.triggerPrefixCls}-placement-`;\n      const start = this.overlay.className.indexOf(stringMach);\n      const end = this.overlay.className.indexOf(\" \", start + stringMach.length);\n      if (start >= 0) {\n        currentPlacement = this.overlay.className.substr(start, end-start);\n      } else {\n        currentPlacement = Overlay.appliedStylePositionMap.get(this.initialPlacement).class;\n      }\n      let newPlacement = stringMach + Overlay.appliedStylePositionMap.get(this.placement).class;\n      this.overlay.classList.replace(currentPlacement, newPlacement);\n    }\n  }\n\n  /**\n   * Loads all important dimensions of the key elements (container of the trigger, trigger & overlay)\n   * into domType.domInfo structures. This could be accessed directly, except absolute positions.\n   * Also simplifies mocking.\n   * @param firstTime - if this method is called first time, then no need to load information on\n   *  container, as it was already loaded in the constructor. This is due to the fact that first time,\n   *  when overlay is added it has default left set to -9999 which causes the scrollbars to \n   * appear (which will be gone by the time overlay becomes visible). Scrollbars change\n   *  dimensions, so often calculations were incorrect.\n   */\n  private getKeyElementDimensions(firstTime: boolean) {\n    if (!firstTime) {\n      this.containerInfo = domInfoHelper.getInfo(this.container);\n      this.calculateScrollBarSizes()\n    }    \n    this.triggerInfo = domInfoHelper.getInfo(this.trigger);\n    this.overlayInfo = domInfoHelper.getInfo(this.overlay);    \n  }\n\n  /**\n   * Calculates trigger top & bottom positions and trigger height and\n   * uses these to return nominal position values depending on placement and\n   * expected attachment point (top/bottom)\n   * @returns verticalPosition\n   */\n  private getVerticalPosition(): verticalPosition {\n    let position: verticalPosition;\n    //usually first offsetHeight is taken, as the measurement contains the borders\n    this.triggerPosition.height = this.triggerInfo.offsetHeight != 0 ? this.triggerInfo.offsetHeight \n    : this.triggerInfo.clientHeight;    \n    if (this.overlayPreset) {\n      this.triggerPosition.top = this.triggerInfo.absoluteTop + this.overlayPreset.y;\n      this.triggerPosition.height = 0;\n    } else {\n      this.triggerPosition.top = this.containerInfo.scrollTop + this.triggerInfo.absoluteTop\n        - this.containerInfo.absoluteTop - this.containerInfo.clientTop;\n    }\n    this.triggerPosition.absoluteTop = this.triggerInfo.absoluteTop;\n\n    if (this.selectedVerticalPosition === \"top\"){\n      position = this.verticalCalculation(this.triggerPosition.top, this.triggerPosition.height, this.containerInfo,\n        this.triggerInfo, this.overlayInfo.clientHeight, this.overlayConstraints);\n    }\n    else { //bottom\n      this.triggerPosition.bottom = this.containerInfo.scrollHeight - this.triggerPosition.top - this.triggerPosition.height;\n      position = this.verticalCalculation(this.triggerPosition.bottom, this.triggerPosition.height, this.containerInfo,\n        this.triggerInfo, this.overlayInfo.clientHeight, this.overlayConstraints);\n    }\n    return position;\n  }\n\n  /**\n   * Calculates trigger left & right positions and trigger width and\n   * uses these to return nominal position values depending on placement and\n   * expected attachment point (left/right)\n   * @returns verticalPosition\n   */\n  private getHorizontalPosition(): horizontalPosition {\n    let position: horizontalPosition;\n    //usually first offsetHeight is taken, as the measurement contains the borders    \n    this.triggerPosition.width = this.triggerInfo.offsetWidth != 0 ? this.triggerInfo.offsetWidth : this.triggerInfo.clientWidth;\n    \n    //let triggerLeft: number;\n    if (this.overlayPreset) {\n      this.triggerPosition.left = this.triggerInfo.absoluteLeft + this.overlayPreset.x;\n      this.triggerPosition.width = 0;\n    } else {\n      this.triggerPosition.left = this.containerInfo.scrollLeft + this.triggerInfo.absoluteLeft\n        - this.containerInfo.absoluteLeft - this.containerInfo.clientLeft;\n    }\n    this.triggerPosition.absoluteLeft = this.triggerInfo.absoluteLeft;\n\n    if (this.selectedHorizontalPosition === \"left\"){      \n      position = this.horizontalCalculation(this.triggerPosition.left, this.triggerPosition.width, this.containerInfo,\n        this.triggerInfo, this.overlayInfo.clientWidth, this.overlayConstraints);\n    }\n    else { //right\n      this.triggerPosition.right = this.containerInfo.scrollWidth - this.triggerPosition.left - this.triggerPosition.width;\n      position = this.horizontalCalculation(this.triggerPosition.right, this.triggerPosition.width, this.containerInfo,\n        this.triggerInfo, this.overlayInfo.clientWidth, this.overlayConstraints);\n    }\n    return position;    \n  }\n\n  /**\n   * Responsible for calling logic that handles situation when calculated overlay position\n   * is causing overlay to be partially rendered invisible. The goal is to adjust placement \n   * in such a way, so the overlay is fully visible.\n   * @returns void\n   */\n  private adjustToContainerBoundaries() {\n    if (this.boundyAdjustMode === TriggerBoundyAdjustMode.None) {\n      return;\n    }    \n\n    if (this.calculationsToPerform.has(\"vertical\")) {\n      this.adjustVerticalToContainerBoundaries();\n    }\n\n    if (this.calculationsToPerform.has(\"horizontal\")) {\n      this.adjustHorizontalToContainerBoundaries();\n    }\n  }\n\n  private setBodyBoundayrSize() {\n      const window = domInfoHelper.getWindow();      \n      const scroll = domInfoHelper.getScroll();\n      this.bodyBoundarySize = {\n        top : scroll.y,\n        left: scroll.x,\n        right: window.innerWidth + scroll.x,\n        bottom: window.innerHeight + scroll.y\n      };     \n  }\n\n  /**\n   * Retrieves information on current logical viewport (visible area). For \n   * InView this means actual viewport area (what you see in the browser - either the \n   * body or the scrolled to area in a container) or for InScroll this means total\n   * area of the container (or body).\n   * @returns coordinates - absolute values measuring from top = 0 and left = 0 (first \n   * pixels of the container)\n   */\n  private getContainerBoundarySize(): coordinates {    \n    if (this.boundyAdjustMode === TriggerBoundyAdjustMode.InScroll) {      \n      if (!this.isContainerBody) {\n        this.setBodyBoundayrSize();\n      }\n      return { \n          left: 0,\n          right: this.containerInfo.scrollWidth,\n          top: 0,\n          bottom: this.containerInfo.scrollHeight\n        };\n    }        \n    this.setBodyBoundayrSize();\n\n    if (this.isContainerBody) {       \n      return this.bodyBoundarySize;\n    } else {         \n      //special care is needed when evaluating viewport of the container\n      const parentIsInsignificant = this.container.parentElement.clientHeight === 0\n        || this.container.parentElement.clientWidth === 0;\n      const verticalScrollBasedOnParent = !parentIsInsignificant\n        && this.container.parentElement.clientHeight < this.containerInfo.clientHeight;\n      const horizontalScrollBasedOnParent = !parentIsInsignificant\n        && this.container.parentElement.clientWidth < this.containerInfo.clientWidth;\n\n      let clientHeight: number;\n      let clientWidth: number;\n      let scrollTop: number;\n      let scrollLeft: number;\n\n      if (verticalScrollBasedOnParent) {\n        clientHeight = this.container.parentElement.clientHeight;\n        scrollTop = this.container.parentElement.scrollTop;\n      } else {\n        clientHeight = this.containerInfo.clientHeight;\n        scrollTop = this.containerInfo.scrollTop;\n      }\n\n      if (horizontalScrollBasedOnParent) {\n        clientWidth = this.container.parentElement.clientWidth;clientWidth;\n        scrollLeft = this.container.parentElement.scrollLeft;\n      } else {\n        clientWidth = this.containerInfo.clientWidth;\n        scrollLeft = this.containerInfo.scrollLeft;\n      }\n          \n      return { \n        top : scrollTop,\n        bottom: scrollTop + clientHeight,\n        left: scrollLeft,\n        right: scrollLeft + clientWidth\n      };                \n    }  \n  }\n\n  /**\n   * Returns how much height of the overlay is visible in current viewport \n   */\n  private getOverlayVisibleHeight(visibleIn: \"container\" | \"body\"): number {\n    let boundary: coordinates;\n    let top: number;    \n    if (visibleIn === \"container\") {\n      boundary = this.containerBoundarySize;\n      top = this.triggerPosition.top;\n    } else {\n      boundary = this.bodyBoundarySize;\n      top = this.triggerPosition.absoluteTop;\n    }\n\n    if (this.selectedVerticalPosition === \"top\") {\n      return boundary.bottom - (top + this.triggerPosition.height);\n    } else {\n      return top - boundary.top;\n    }    \n  }\n\n  /**\n   * Returns how much width of the overlay is visible in current viewport \n   */\n  private getOverlayVisibleWidth(visibleIn: \"container\" | \"body\"): number {    \n    let boundary: coordinates;\n    let left: number;    \n    if (visibleIn === \"container\") {\n      boundary = this.containerBoundarySize;\n      left = this.triggerPosition.left;\n    } else {\n      boundary = this.bodyBoundarySize;\n      left = this.triggerPosition.absoluteLeft;\n    }\n\n    if (this.selectedHorizontalPosition === \"left\") {\n      return boundary.right - (left + this.triggerPosition.width);\n    } else {\n      return left - boundary.left;\n    }\n  }\n\n  /**\n   * Checks if current position actually fits in the container and if not, then reverses\n   * the placement. Then calculates which already calculated placements has the largest horizontal \n   * area of the overlay visible and picks the calculation with largest area.\n   */\n  private adjustHorizontalToContainerBoundaries() {\n    if (!this.overlayFitsContainer(\"horizontal\", this.position.left, this.position.right)) {\n      const positionCache: overlayPosition = { ...this.position };\n      const selectedPositionCache = this.selectedHorizontalPosition;\n      const placementCache = this.placement;\n      const horizontalCalculationCache = this.horizontalCalculation;\n      const visibleWidthBeforeAdjustment = this.getOverlayVisibleWidth(\"container\");\n      let visibleWidthInBodyBeforeAdjustment: number;\n      if (this.isContainerOverBody) {\n        visibleWidthInBodyBeforeAdjustment = this.getOverlayVisibleWidth(\"body\");\n      } else {\n        visibleWidthInBodyBeforeAdjustment = visibleWidthBeforeAdjustment\n      };      \n\n      this.getHorizontalAdjustment();\n\n      const visibleWidthAfterAdjustment = this.getOverlayVisibleWidth(\"container\");\n      let visibleWidthInBodyAfterAdjustment: number;\n      if (this.isContainerOverBody) {\n        visibleWidthInBodyAfterAdjustment = this.getOverlayVisibleWidth(\"body\");\n      } else {\n        visibleWidthInBodyAfterAdjustment = visibleWidthAfterAdjustment\n      };        \n\n      if (\n        !(visibleWidthInBodyBeforeAdjustment < visibleWidthInBodyAfterAdjustment \n          && visibleWidthInBodyAfterAdjustment > 0\n          && visibleWidthInBodyAfterAdjustment - visibleWidthInBodyBeforeAdjustment >= 0)        \n        ||\n        !(visibleWidthBeforeAdjustment < visibleWidthAfterAdjustment && visibleWidthAfterAdjustment > 0)) {        \n        this.position = positionCache;\n        this.selectedHorizontalPosition = selectedPositionCache;\n        this.placement = placementCache;\n        this.horizontalCalculation = horizontalCalculationCache;\n      }\n    }\n  }\n\n  /**\n   * Checks if current position actually fits in the container and if not, then reverses\n   * the placement. Then calculates which already calculated placements has the largest vertical \n   * area of the overlay visible and picks the calculation with largest area.\n   */\n  private adjustVerticalToContainerBoundaries() {\n    if (!this.overlayFitsContainer(\"vertical\", this.position.top, this.position.bottom)) {\n      const positionCache: overlayPosition = { ...this.position };\n      const selectedPositionCache = this.selectedVerticalPosition;\n      const placementCache = this.placement;\n      const verticalCalculationCache = this.verticalCalculation;\n      const visibleHeightBeforeAdjustment = this.getOverlayVisibleHeight(\"container\");\n      let visibleHeightInBodyBeforeAdjustment: number;\n      if (this.isContainerOverBody) {\n        visibleHeightInBodyBeforeAdjustment = this.getOverlayVisibleHeight(\"body\");\n      } else {\n        visibleHeightInBodyBeforeAdjustment = visibleHeightBeforeAdjustment\n      };\n\n      this.getVerticalAdjustment();      \n\n      const visibleHeightAfterAdjustment = this.getOverlayVisibleHeight(\"container\");\n      let visibleHeightInBodyAfterAdjustment: number;\n      if (this.isContainerOverBody) {\n        visibleHeightInBodyAfterAdjustment = this.getOverlayVisibleHeight(\"body\");\n      } else {\n        visibleHeightInBodyAfterAdjustment = visibleHeightAfterAdjustment\n      };          \n\n      if (\n        !(visibleHeightInBodyBeforeAdjustment < visibleHeightInBodyAfterAdjustment \n          && visibleHeightInBodyAfterAdjustment > 0 \n          && visibleHeightInBodyAfterAdjustment - visibleHeightInBodyBeforeAdjustment >= 0)\n        ||\n        !(visibleHeightBeforeAdjustment < visibleHeightAfterAdjustment && visibleHeightAfterAdjustment > 0)) {        \n        this.position = positionCache;\n        this.selectedVerticalPosition = selectedPositionCache;\n        this.placement = placementCache;\n        this.verticalCalculation = verticalCalculationCache;\n      }\n    }\n  }\n\n  private overlayFitsContainer(type: \"horizontal\" | \"vertical\", start: number, end: number): boolean {    \n    if (type === \"horizontal\") {\n      const endExpressedAsLeft = start + this.overlayInfo.clientWidth;\n      return this.containerBoundarySize.left <= start\n          && start <= this.containerBoundarySize.right //overlay left is between container left and right\n          && this.containerBoundarySize.left <= endExpressedAsLeft\n          && endExpressedAsLeft <= this.containerBoundarySize.right //and overlay right is between container left and right\n    }\n    const endExpressedAsTop = start + this.overlayInfo.clientHeight;\n    return this.containerBoundarySize.top <= start\n        && start <= this.containerBoundarySize.bottom //overlay top is between container top and bottom\n        && this.containerBoundarySize.top <= endExpressedAsTop \n        && endExpressedAsTop <= this.containerBoundarySize.bottom //and overlay bottom is between container top and bottom\n  }\n\n  /**\n   * Applies basic adjustment - switches verticaly placement (top -> bottom & bottom -> top) \n   * and recalculates based on the newly set placement \n   */\n  private getVerticalAdjustment() {\n    this.placement = Overlay.reverseVerticalPlacementMap.get(this.placement)(this.selectedVerticalPosition);\n    this.selectedVerticalPosition = Overlay.appliedStylePositionMap.get(this.placement).vertical;\n    this.verticalCalculation = Overlay.setVerticalCalculation(this.placement, this.selectedVerticalPosition);\n    const verticalPosition = this.getVerticalPosition();\n    this.position.top = verticalPosition.top;\n    this.position.bottom = verticalPosition.bottom;\n  }\n\n  /**\n   * Applies basic adjustment - switches horizontal placement (left -> right & right -> left)\n   * and recalculates based on the newly set placement\n   */\n  private getHorizontalAdjustment() {\n    this.placement = Overlay.reverseHorizontalPlacementMap.get(this.placement)(this.selectedHorizontalPosition);\n    this.selectedHorizontalPosition = Overlay.appliedStylePositionMap.get(this.placement).horizontal;\n    this.horizontalCalculation = Overlay.setHorizontalCalculation(this.placement, this.selectedHorizontalPosition);\n    const horizontalPosition = this.getHorizontalPosition();\n    this.position.left = horizontalPosition.left;\n    this.position.right = horizontalPosition.right;    \n  }  \n}","﻿import { domInfoHelper, eventHelper, domManipulationHelper, domTypes } from '../dom/exports'\nimport { Placement, TriggerBoundyAdjustMode, overlayConstraints, overlayPosition, Overlay } from './overlay'\nimport { state } from '../stateProvider';\n\nexport class overlayHelper {\n  static overlayRegistry: { [key: string]: Overlay} = {};\n\n  static addOverlayToContainer(blazorId: string, \n    overlaySelector, triggerSelector, placement: Placement,  containerSelector: string,\n    triggerBoundyAdjustMode: TriggerBoundyAdjustMode, triggerIsWrappedInDiv: boolean, triggerPrefixCls: string,\n    verticalOffset: number, horizontalOffset: number, arrowPointAtCenter: boolean,    \n    overlayTop?: number, overlayLeft?: number\n  ): overlayPosition {      \n    const overlayElement = domInfoHelper.get(overlaySelector) as HTMLDivElement;    \n    const containerElement = domInfoHelper.get(containerSelector) as HTMLElement;\n    const triggerElement = domInfoHelper.get(triggerSelector) as HTMLElement;\n\n    if (!domManipulationHelper.addElementTo(overlaySelector, containerElement)) {\n      console.log(\"Failed to add overlay. Details:\", {\n         triggerPrefixCls: triggerPrefixCls,\n         overlaySelector: overlaySelector,\n         containerElement: containerElement\n      } );\n      return null;\n    }    \n\n    let overlayPresets: domTypes.position;\n    if (overlayTop || overlayLeft) {\n      overlayPresets = { x: overlayLeft, y: overlayTop };\n    }\n\n    let overlayConstraints: overlayConstraints = {\n      verticalOffset: verticalOffset,\n      horizontalOffset: horizontalOffset,\n      arrowPointAtCenter: arrowPointAtCenter\n    };\n\n    let overlay = new Overlay(blazorId, overlayElement, containerElement, triggerElement, placement, triggerBoundyAdjustMode, triggerIsWrappedInDiv, triggerPrefixCls, overlayConstraints);   \n    //register object in store, so it can be retrieved during update/dispose\n    this.overlayRegistry[blazorId] = overlay;\n    \n    return overlay.calculatePosition(false, true, overlayPresets);\n  }\n\n\n  static updateOverlayPosition(blazorId: string, overlaySelector, triggerSelector, placement: Placement,  containerSelector: string,\n    triggerBoundyAdjustMode: TriggerBoundyAdjustMode, triggerIsWrappedInDiv: boolean, triggerPrefixCls: string,\n    verticalOffset: number, horizontalOffset: number, arrowPointAtCenter: boolean,  \n    overlayTop?: number, overlayLeft?: number): overlayPosition {\n    const overlay = this.overlayRegistry[blazorId];\n    if (overlay){\n      let overlayPresets: domTypes.position;\n        if (overlayTop || overlayLeft) {\n          overlayPresets = { x: overlayLeft, y: overlayTop };\n        }      \n      return overlay.calculatePosition(false, false, overlayPresets);      \n    } else {\n      //When page is slow, it may happen that rendering of an overlay may not happen, even if \n      //blazor thinks it did happen. In such a case, when overlay object is not found, just try\n      //to render it again.\n      return overlayHelper.addOverlayToContainer(blazorId, overlaySelector, triggerSelector, placement,  containerSelector,triggerBoundyAdjustMode, triggerIsWrappedInDiv, triggerPrefixCls, \n      verticalOffset, horizontalOffset, arrowPointAtCenter,  \n      overlayTop, overlayLeft);      \n    }    \n  }\n\n  static deleteOverlayFromContainer(blazorId: string) {\n    const overlay = this.overlayRegistry[blazorId];\n    if (overlay) {      \n      overlay.dispose();\n      delete this.overlayRegistry[blazorId];\n    }\n  }\n\n  static addPreventEnterOnOverlayVisible(element, overlayElement) {\n    if (element && overlayElement) {\n      let dom: HTMLElement = domInfoHelper.get(element);\n      if (dom) {\n        state.eventCallbackRegistry[element.id + \"keydown:Enter\"] = (e) => eventHelper.preventKeyOnCondition(e, \"enter\", () => overlayElement.offsetParent !== null);\n        dom.addEventListener(\"keydown\", state.eventCallbackRegistry[element.id + \"keydown:Enter\"], false);\n      }\n    }\n  }\n\n  static removePreventEnterOnOverlayVisible(element) {\n    if (element) {\n      let dom: HTMLElement = domInfoHelper.get(element);\n      if (dom) {\n        dom.removeEventListener(\"keydown\", state.eventCallbackRegistry[element.id + \"keydown:Enter\"]);\n        state.eventCallbackRegistry[element.id + \"keydown:Enter\"] = null; \n      }\n    }\n  }\n}\n\n","﻿export class tableHelper {\n  static bindTableScroll(bodyRef, tableRef, headerRef, scrollX, scrollY) {\n    bodyRef.bindScroll = () => {\n      if (scrollX) {\n        tableHelper.SetScrollPositionClassName(bodyRef, tableRef);\n      }\n      if (scrollY) {\n        headerRef.scrollLeft = bodyRef.scrollLeft;\n      }\n    }\n    bodyRef.bindScroll();\n    bodyRef.addEventListener('scroll', bodyRef.bindScroll);\n    window.addEventListener('resize', bodyRef.bindScroll);\n  }\n\n  static unbindTableScroll(bodyRef) {\n    if (bodyRef) {\n      bodyRef.removeEventListener('scroll', bodyRef.bindScroll);\n      window.removeEventListener('resize', bodyRef.bindScroll);\n    }\n  }\n\n  static SetScrollPositionClassName(bodyRef, tableRef) {\n\n    let scrollLeft = bodyRef.scrollLeft;\n    let scrollWidth = bodyRef.scrollWidth;\n    let clientWidth = bodyRef.clientWidth;\n\n    let pingLeft = false;\n    let pingRight = false;\n\n    if ((scrollWidth == clientWidth && scrollWidth != 0)) {\n      pingLeft = false;\n      pingRight = false;\n    }\n    else if (scrollLeft == 0) {\n      pingLeft = false;\n      pingRight = true;\n    }\n    else if (Math.abs(scrollWidth - (scrollLeft + clientWidth)) <= 1) {\n      pingRight = false;\n      pingLeft = true;\n    }\n    else {\n      pingLeft = true;\n      pingRight = true;\n    }\n\n    pingLeft ? tableRef.classList.add(\"ant-table-ping-left\") : tableRef.classList.remove(\"ant-table-ping-left\");\n    pingRight ? tableRef.classList.add(\"ant-table-ping-right\") : tableRef.classList.remove(\"ant-table-ping-right\");\n  }\n}","﻿type fileInfo = {\n  fileName: string,\n  size: number,\n  objectURL: string,\n  type: string\n}\n\nexport class uploadHelper {\n  static addFileClickEventListener(btn: HTMLElement) {\n    if (btn.addEventListener) {\n      btn.addEventListener(\"click\", uploadHelper.fileClickEvent);\n    }\n  }\n\n  static removeFileClickEventListener(btn: HTMLElement) {\n    btn.removeEventListener(\"click\", uploadHelper.fileClickEvent);\n  }\n\n  private static fileClickEvent(e: MouseEvent) {\n    e.stopPropagation();\n    const fileId = (e.currentTarget as HTMLSpanElement).attributes[\"data-fileid\"].nodeValue;\n    const element = document.getElementById(fileId) as HTMLInputElement;\n    element.click();\n  }\n\n  static clearFile(element) {\n    element.setAttribute(\"type\", \"input\");\n    element.value = '';\n    element.setAttribute(\"type\", \"file\");\n  }\n\n  static getFileInfo(element: HTMLInputElement) {\n    if (element.files && element.files.length > 0) {\n      let fileInfo = Array<fileInfo>();\n      for (var i = 0; i < element.files.length; i++) {\n        let file = element.files[i];\n        const objectUrl = this.getObjectURL(file);\n        fileInfo.push({\n          fileName: file.name,\n          size: file.size,\n          objectURL: objectUrl,\n          type: file.type\n        });\n      }\n\n      return fileInfo;\n    }\n  }\n\n  private static getObjectURL(file: File): string {\n    var url = null;\n    if (window.URL != undefined) {\n      url = window.URL.createObjectURL(file);\n    } else if (window.webkitURL != undefined) {\n      url = window.webkitURL.createObjectURL(file);\n    }\n    return url;\n  }\n\n  static uploadFile(element, index, data, headers, fileId, url, name, instance, percentMethod, successMethod, errorMethod, method: string) {\n    let formData = new FormData();\n    var file = element.files[index];\n    var size = file.size;\n    formData.append(name, file);\n    if (data != null) {\n      for (var key in data) {\n        formData.append(key, data[key]);\n      }\n    }\n    const req = new XMLHttpRequest()\n    req.onreadystatechange = function () {\n      if (req.readyState === 4) {\n        // #1655 Any 2xx response code is okay\n        if (req.status < 200 || req.status > 299) {\n          instance.invokeMethodAsync(errorMethod, fileId, `{\"status\": ${req.status}}`);\n          return;\n        }\n        instance.invokeMethodAsync(successMethod, fileId, req.responseText);\n      }\n    }\n    req.upload.onprogress = function (event) {\n      var percent = Math.floor(event.loaded / size * 100);\n      instance.invokeMethodAsync(percentMethod, fileId, percent);\n    }\n    req.onerror = function (e) {\n      instance.invokeMethodAsync(errorMethod, fileId, \"error\");\n    }\n    req.open(method, url, true)\n    if (headers != null) {\n      for (var header in headers) {\n        req.setRequestHeader(header, headers[header]);\n      }\n    }\n    req.send(formData)\n  }\n}","﻿\nconst throttle = (fn, threshold = 160) => {\n    let timeout;\n    var start = +new Date;\n    return function (...args) {\n        let context = this, curTime = +new Date() - 0;\n        //总是干掉事件回调\n        window.clearTimeout(timeout);\n        if (curTime - start >= threshold) {\n            //只执行一部分方法，这些方法是在某个时间段内执行一次\n            fn.apply(context, args);\n            start = curTime;\n        }\n        else {\n            //让方法在脱离事件后也能执行一次\n            timeout = window.setTimeout(() => {\n                //@ts-ignore\n                fn.apply(this, args);\n            }, threshold);\n        }\n    };\n}\n\nconst eventMap = new Map<HTMLElement, Dragger>();\n\nconst defaultOptions = {\n    inViewport: true\n}\n\nclass Dragger {\n\n    private _triggler: HTMLElement = null;\n    private _container: HTMLElement = null;\n    private _options: any = null;\n    private _state: any = null;\n    private _isFirst: boolean = true;\n    private _style: string = null;\n\n    constructor(triggler: HTMLElement, container: HTMLElement, dragInViewport: boolean) {\n        this._triggler = triggler;\n        this._container = container;\n        this._options = Object.assign({}, defaultOptions, {\n            inViewport: dragInViewport\n        });\n        this._state = {\n            isInDrag: false,\n            mX: 0, // mouse x\n            mY: 0, // mouse y\n            domStartX: 0, // on mousedown, the mouse x\n            domStartY: 0, // on mousedown, the mouse y            \n        }\n    }\n\n    getContainerPos() {\n        const rect = this._container.getBoundingClientRect();\n        return {\n            left: rect.left,\n            top: rect.top\n        }\n    }\n\n    onMousedown = (e) => {\n        const state = this._state;\n        state.isInDrag = true;\n        state.mX = e.clientX;\n        state.mY = e.clientY;\n        this._container.style.position = \"absolute\";\n        const { left, top } = this.getContainerPos();\n\n        if (this._isFirst) {\n\n            state.domMaxY = document.documentElement.clientHeight\n                - this._container.offsetHeight - 1;\n            state.domMaxX = document.documentElement.clientWidth\n                - this._container.offsetWidth - 1;\n\n            this._container.style.left = left + 'px';\n            this._container.style.top = top + 'px';\n\n            if (!this._style) {\n                this._style = this._container.getAttribute(\"style\");\n            }\n\n            this._isFirst = false;\n        }\n\n        state.domStartX = left;\n        state.domStartY = top;\n    }\n\n    onMouseup = (e) => {\n        const state = this._state;\n\n        state.isInDrag = false;\n\n        const { left, top } = this.getContainerPos();\n        state.domStartX = left;\n        state.domStartY = top;\n    }\n\n    onMousemove = throttle((e) => {\n        const state = this._state;\n        if (state.isInDrag) {\n            var nowX = e.clientX,\n                nowY = e.clientY,\n                disX = nowX - state.mX,\n                disY = nowY - state.mY;\n\n            var newDomX = state.domStartX + disX;\n            var newDomY = state.domStartY + disY;\n            if (this._options.inViewport) {\n                if (newDomX < 0) {\n                    newDomX = 0;\n                }\n                else if (newDomX > state.domMaxX) {\n                    newDomX = state.domMaxX;\n                }\n                if (newDomY < 0) {\n                    newDomY = 0;\n                }\n                else if (newDomY > state.domMaxY) {\n                    newDomY = state.domMaxY;\n                }\n            }\n            this._container.style.position = \"absolute\";\n            this._container.style.margin = \"0\";\n            this._container.style.paddingBottom = \"0\";\n            this._container.style.left = newDomX + \"px\";\n            this._container.style.top = newDomY + \"px\";\n        }\n    }, 10).bind(this);\n\n    onResize = throttle((e) => {\n        const state = this._state;\n\n        state.domMaxY = document.documentElement.clientHeight\n            - this._container.offsetHeight - 1;\n        state.domMaxX = document.documentElement.clientWidth\n            - this._container.offsetWidth - 1;\n        state.domStartY = parseInt(this._container.style.top);\n        state.domStartX = parseInt(this._container.style.left);\n        if (state.domStartY > state.domMaxY) {\n            if (state.domMaxY > 0) {\n                this._container.style.top = state.domMaxY + \"px\";\n            }\n        }\n        if (state.domStartX > state.domMaxX) {\n            this._container.style.left = state.domMaxX + \"px\";\n        }\n    }, 10).bind(this);\n\n    bindDrag() {\n        const triggler = this._triggler;\n        const options = this._options;\n\n        triggler.addEventListener(\"mousedown\", this.onMousedown, false);\n        window.addEventListener(\"mouseup\", this.onMouseup, false);\n        document.addEventListener(\"mousemove\", this.onMousemove);\n        if (options.inViewport) {\n            window.addEventListener(\"resize\", this.onResize, false);\n        }\n    }\n\n    unbindDrag() {\n        const triggler = this._triggler;\n\n        triggler.removeEventListener(\"mousedown\", this.onMousedown, false);\n        window.removeEventListener(\"mouseup\", this.onMouseup, false);\n        document.removeEventListener(\"mousemove\", this.onMousemove);\n        if (this._options.inViewport) {\n            window.removeEventListener(\"resize\", this.onResize, false);\n        }\n    }\n\n    resetContainerStyle() {\n        if (this._style !== null) {\n            this._isFirst = true;\n            this._container.setAttribute(\"style\", this._style);\n        }\n    }\n}\n\nfunction enableDraggable(triggler: HTMLElement, container: HTMLElement, dragInViewport: boolean = true) {\n    let dragger = eventMap.get(triggler);\n    if (!dragger) {\n        dragger = new Dragger(triggler, container, dragInViewport);\n        eventMap.set(triggler, dragger);\n    } \n    dragger.bindDrag();\n}\n\nfunction disableDraggable(triggler: HTMLElement) {\n    const dragger = eventMap.get(triggler);\n    if (dragger) {\n        dragger.unbindDrag();\n    }\n}\n\nfunction resetModalPosition(triggler: HTMLElement) {\n    const dragger = eventMap.get(triggler);\n    if (dragger) {\n        dragger.resetContainerStyle();\n    }\n}\n\nexport { enableDraggable, disableDraggable, resetModalPosition };","﻿import { domInfoHelper } from './exports';\nimport { state } from '../stateProvider';\n\nexport class eventHelper {\n  static triggerEvent(element: HTMLInputElement, eventType: string, eventName: string) {\n    //TODO: replace with event constructors https://developer.mozilla.org/en-US/docs/Web/API/CustomEvent\n    //Not used \n    const evt = document.createEvent(eventType);\n    evt.initEvent(eventName);\n    return element.dispatchEvent(evt);\n  }\n\n  static addDomEventListener(element, eventName: string, preventDefault: boolean, invoker: any) {\n    const callback = args => {\n      const obj = {};\n      for (let k in args) {\n        if (k !== 'originalTarget') { //firefox occasionally raises Permission Denied when this property is being stringified\n          obj[k] = args[k];\n        }\n      }\n      const json = JSON.stringify(obj, (k, v) => {\n        if (v instanceof Node) return 'Node';\n        if (v instanceof Window) return 'Window';\n        return v;\n      }, ' ');\n      setTimeout(function () { invoker.invokeMethodAsync('Invoke', json) }, 0);\n      if (preventDefault === true) {\n        args.preventDefault();\n      }\n    };\n\n    if (element === 'window') {\n      if (eventName === 'resize') {\n        window.addEventListener(eventName, this.debounce(() => callback({ innerWidth: window.innerWidth, innerHeight: window.innerHeight }), 200, false));\n      } else {\n        window.addEventListener(eventName, callback);\n      }\n    } else {\n      const dom = domInfoHelper.get(element);\n      if (dom) {\n        (dom as HTMLElement).addEventListener(eventName, callback);\n      }\n    }\n  }  \n\n  static addDomEventListenerToFirstChild(element, eventName, preventDefault, invoker) {\n    const dom = domInfoHelper.get(element);\n\n    if (dom && dom.firstElementChild) {\n      this.addDomEventListener(dom.firstElementChild, eventName, preventDefault, invoker);\n    }\n  }\n\n  static addPreventKeys(inputElement, keys: string[]) {\n    if (inputElement) {\n      const dom = domInfoHelper.get(inputElement);\n      keys = keys.map(function (x) { return x.toUpperCase(); })\n      state.eventCallbackRegistry[inputElement.id + \"keydown\"] = (e) => this.preventKeys(e, keys);\n      (dom as HTMLElement).addEventListener(\"keydown\", state.eventCallbackRegistry[inputElement.id + \"keydown\"], false);\n    }\n  }\n\n  static preventKeyOnCondition(e: KeyboardEvent, key: string, check: () => boolean) {\n    if (e.key.toUpperCase() === key.toUpperCase() && check()) {\n      e.preventDefault();\n      return false;\n    }\n  }\n\n  static removePreventKeys(inputElement) {\n    if (inputElement) {\n      const dom = domInfoHelper.get(inputElement);\n      if (dom) {\n        (dom as HTMLElement).removeEventListener(\"keydown\", state.eventCallbackRegistry[inputElement.id + \"keydown\"]);\n        state.eventCallbackRegistry[inputElement.id + \"keydown\"] = null;\n      }\n    }\n  }\n\n  private static debounce(func, wait, immediate) {\n    var timeout;\n    return () => {\n      const context = this, args = arguments;\n      const later = () => {\n        timeout = null;\n        if (!immediate) func.apply(this, args);\n      };\n      const callNow = immediate && !timeout;\n      clearTimeout(timeout);\n      timeout = setTimeout(later, wait);\n      if (callNow) func.apply(context, args);\n    };\n  };\n\n  private static preventKeys(e: KeyboardEvent, keys: string[]) {\n    if (keys.indexOf(e.key.toUpperCase()) !== -1) {\n      e.preventDefault();\n      return false;\n    }\n  }\n}","﻿export { infoHelper as domInfoHelper } from './infoHelper';\nexport { manipulationHelper as domManipulationHelper } from './manipulationHelper';\nexport { eventHelper } from './eventHelper';\nexport * as domTypes from './types';","﻿import { domTypes } from './exports'\n\nexport class infoHelper {\n  static getWindow() {\n    return {\n      innerWidth: window.innerWidth,\n      innerHeight: window.innerHeight\n    };\n  }\n\n  static get(element: any) {\n    if (!element) {\n      element = document.body;\n    } else if (typeof element === 'string') {\n      if (element === 'document') {\n        return document;\n      }\n      element = document.querySelector(element!)\n    }\n    return element;\n  }\n\n  static getInfo(element: any): domTypes.domInfo {\n    let domElement = this.get(element);\n    if (!domElement) {\n      domElement = {};\n    }\n    const absolutePosition = this.getElementAbsolutePos(domElement);\n    const result: domTypes.domInfo = {\n      offsetTop: domElement.offsetTop || 0,\n      offsetLeft: domElement.offsetLeft || 0,\n      offsetWidth: domElement.offsetWidth || 0,\n      offsetHeight: domElement.offsetHeight || 0,\n      scrollHeight: domElement.scrollHeight || 0,\n      scrollWidth: domElement.scrollWidth || 0,\n      scrollLeft: domElement.scrollLeft || 0,\n      scrollTop: domElement.scrollTop || 0,\n      clientTop: domElement.clientTop || 0,\n      clientLeft: domElement.clientLeft || 0,\n      clientHeight: domElement.clientHeight || 0,\n      clientWidth: domElement.clientWidth || 0,\n      selectionStart: domElement.selectionStart || 0,\n      absoluteTop: Math.round(absolutePosition.y),\n      absoluteLeft: Math.round(absolutePosition.x)\n    };\n    return result;\n  }\n\n  static getElementAbsolutePos(element: any): domTypes.position {\n    const res: domTypes.position = {\n      x: 0,\n      y: 0\n    };\n    if (element !== null) {\n      if (element.getBoundingClientRect) {\n        const viewportElement = document.documentElement;\n        const box = element.getBoundingClientRect();\n        const scrollLeft = viewportElement.scrollLeft;\n        const scrollTop = viewportElement.scrollTop;\n\n        res.x = box.left + scrollLeft;\n        res.y = box.top + scrollTop;\n      }\n    }\n    return res;\n  }\n\n  static getBoundingClientRect(element: any): domTypes.domRect {\n    const domElement = this.get(element);\n    if (domElement && domElement.getBoundingClientRect) {\n      const rect = domElement.getBoundingClientRect();\n      // Fixes #1468. This wrapping is necessary for old browsers. Remove this when one day we no longer support them.\n      return {\n        width: rect.width,\n        height: rect.height,\n        top: rect.top,\n        right: rect.right,\n        bottom: rect.bottom,\n        left: rect.left,\n        x: rect.x,\n        y: rect.y\n      };\n    }\n    return null;\n  }\n\n  static getFirstChildDomInfo(element: any) {\n    const domElement = this.get(element);\n    if (domElement) {\n      if (domElement.firstElementChild) {\n        return this.getInfo(domElement.firstElementChild);\n      } else {\n        return this.getInfo(domElement);\n      }\n    }\n    return null;\n  }\n\n  static getActiveElement() {\n    const element = document.activeElement;\n    const id = element.getAttribute(\"id\") || \"\";\n    return id;\n  }\n\n  static getScroll() {\n    return { x: window.pageXOffset, y: window.pageYOffset };\n  }\n\n  static hasFocus(selector) {\n    const dom = this.get(selector);\n    return (document.activeElement === dom);\n  }\n\n  static getInnerText(element) {\n    const dom = this.get(element);\n    if (dom) return dom.innerText;\n    return null;\n  }\n\n  static getMaxZIndex(): number {\n    return [...document.querySelectorAll(\"*\")].reduce((r, e) => Math.max(r, +window.getComputedStyle(e).zIndex || 0), 0)\n  }  \n\n  static isFixedPosition(element) {\n    let node = this.get(element);\n    while (node && node.nodeName.toLowerCase() !== 'body') {\n        if (window.getComputedStyle(node).getPropertyValue('position').toLowerCase() === 'fixed')\n            { return true; }\n        node = node.parentNode;\n    }\n    return false;\n  }\n  \n  static findAncestorWithZIndex(element: HTMLElement): number {\n    let node = this.get(element);\n    let zIndexAsString: string;\n    let zIndex: number;\n    while (node && node.nodeName.toLowerCase() !== 'body') {\n        zIndexAsString = window.getComputedStyle(node).zIndex;\n        zIndex = Number.parseInt(zIndexAsString);\n        if (!Number.isNaN(zIndex)) {\n           return zIndex;\n        }\n        node = node.parentNode;\n    }\n    return null;\n  }\n\n}","﻿import { domInfoHelper } from './exports'\nimport { styleHelper } from '../styleHelper'\nimport { state } from '../stateProvider'\nimport * as enums from '../enums';\n\nexport class manipulationHelper {\n  static addElementToBody(element) {\n    document.body.appendChild(element);\n  }\n\n  static delElementFromBody(element) {\n    document.body.removeChild(element);\n  }\n\n  static addElementTo(addElement, elementSelector): boolean {\n    let parent = domInfoHelper.get(elementSelector);\n    if (parent && addElement) {\n      if (parent instanceof Node && addElement instanceof Node) {\n        parent.appendChild(addElement);\n        return true;\n      } else {\n        console.log(\"does not implement node\", parent, addElement);\n      }\n    }\n    return false;\n  }\n\n  static delElementFrom(delElement, elementSelector) {\n    let parent = domInfoHelper.get(elementSelector);\n    if (parent && delElement) {\n      parent.removeChild(delElement);\n    }\n  }\n\n  static setDomAttribute(element, attributes) {\n    let dom: HTMLElement = domInfoHelper.get(element);\n    if (dom) {\n      for (let key in attributes) {\n        dom.setAttribute(key, attributes[key]);\n      }\n    }\n  }\n\n  static copy(text) {\n    if (!navigator.clipboard) {\n      this.fallbackCopyTextToClipboard(text);\n      return;\n    }\n    navigator.clipboard.writeText(text).then(function () {\n      console.log('Async: Copying to clipboard was successful!');\n    }, function (err) {\n      console.error('Async: Could not copy text: ', err);\n    });\n  }\n\n  private static fallbackCopyTextToClipboard(text) {\n    var textArea = document.createElement(\"textarea\");\n    textArea.value = text;\n\n    // Avoid scrolling to bottom\n    textArea.style.top = \"0\";\n    textArea.style.left = \"0\";\n    textArea.style.position = \"fixed\";\n\n    document.body.appendChild(textArea);\n    textArea.focus();\n    textArea.select();\n\n    try {\n      var successful = document.execCommand('copy');\n      var msg = successful ? 'successful' : 'unsuccessful';\n      console.log('Fallback: Copying text command was ' + msg);\n    } catch (err) {\n      console.error('Fallback: Oops, unable to copy', err);\n    }\n\n    document.body.removeChild(textArea);\n  }\n\n  static focus(selector, noScroll: boolean = false, option: enums.FocusBehavior = enums.FocusBehavior.FocusAtLast) {\n    let dom = domInfoHelper.get(selector);\n    if (!(dom instanceof HTMLElement))\n      throw new Error(\"Unable to focus on invalid element.\");\n\n    dom.focus({\n      preventScroll: noScroll\n    });\n\n    if (dom instanceof HTMLInputElement || dom instanceof HTMLTextAreaElement) {\n      switch (option) {\n        case enums.FocusBehavior.FocusAndSelectAll:\n          dom.select();\n          break;\n        case enums.FocusBehavior.FocusAtFirst:\n          dom.setSelectionRange(0, 0);\n          break;\n        case enums.FocusBehavior.FocusAtLast:\n          dom.setSelectionRange(-1, -1);\n          break;\n      }\n    }\n  }\n\n\n  static blur(selector) {\n    let dom = domInfoHelper.get(selector);\n    if (dom) {\n      dom.blur();\n    }\n  }\n\n  static scrollTo(selector: Element | string, parentElement?: HTMLElement) {\n    const element = domInfoHelper.get(selector);\n    if (parentElement && element && element instanceof HTMLElement) {\n      parentElement.scrollTop = element.offsetTop;\n    } else if (element && element instanceof HTMLElement) {\n        element.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'start' });\n    }    \n  }  \n\n  static slideTo(targetPageY) {\n    const timer = setInterval(function () {\n      const currentY = document.documentElement.scrollTop || document.body.scrollTop;\n      const distance = targetPageY > currentY ? targetPageY - currentY : currentY - targetPageY;\n      const speed = Math.ceil(distance / 10);\n      if (currentY === targetPageY) {\n        clearInterval(timer);\n      } else {\n        window.scrollTo(0, targetPageY > currentY ? currentY + speed : currentY - speed);\n      }\n    }, 10);\n  }\n\n  //copied from https://www.telerik.com/forums/trigger-tab-key-when-enter-key-is-pressed\n  static invokeTabKey() {\n    var currInput = document.activeElement;\n    if (currInput.tagName.toLowerCase() == \"input\") {\n      var inputs = document.getElementsByTagName(\"input\");\n      var currInput = document.activeElement;\n      for (var i = 0; i < inputs.length; i++) {\n        if (inputs[i] == currInput) {\n          var next = inputs[i + 1];\n          if (next && next.focus) {\n            next.focus();\n          }\n          break;\n        }\n      }\n    }\n  }\n\n  static disableBodyScroll() {\n    let body = document.body;\n    const oldBodyCache = {};\n    [\"position\", \"width\", \"overflow\"].forEach((key) => {\n      oldBodyCache[key] = body.style[key];\n    });\n    state.oldBodyCacheStack.push(oldBodyCache);\n    styleHelper.css(body,\n      {\n        \"position\": \"relative\",\n        \"width\": this.hasScrollbar() ? \"calc(100% - 17px)\" : null,\n        \"overflow\": \"hidden\"\n      });\n    styleHelper.addCls(document.body, \"ant-scrolling-effect\");\n  }\n\n  static enableBodyScroll() {\n    let oldBodyCache = state.oldBodyCacheStack.length > 0 ? state.oldBodyCacheStack.pop() : {};\n\n    styleHelper.css(document.body,\n      {\n        \"position\": oldBodyCache[\"position\"] ?? null,\n        \"width\": oldBodyCache[\"width\"] ?? null,\n        \"overflow\": oldBodyCache[\"overflow\"] ?? null\n      });\n    styleHelper.removeCls(document.body, \"ant-scrolling-effect\");\n  }\n\n  static hasScrollbar = () => {\n    let overflow = document.body.style.overflow;\n    if (overflow && overflow === \"hidden\") return false;\n    return document.body.scrollHeight > (window.innerHeight || document.documentElement.clientHeight);\n  }\n\n}","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IiIsInNvdXJjZVJvb3QiOiIifQ==","﻿export enum FocusBehavior {\n  /// <summary>\n  /// When focuses, cursor will move to the last character. \n  /// This is default behavior.\n  /// </summary>\n  FocusAtLast,\n  /// <summary>\n  /// When focuses, cursor will move to the first character\n  /// </summary>\n  FocusAtFirst,\n  /// <summary>\n  /// When focuses, the content will be selected\n  /// </summary>\n  FocusAndSelectAll\n}","﻿import { eventCallback } from './dom/types'\n\n//Singleton \nexport class State {\n  private static instance: State;\n\n  //Stores references to dot net objects (components wrapped in DotNetObjectReference)\n  objReferenceDict: { [key: string]: any } = {};\n\n  //All object references must later be disposed by JS code or by .NET code.\n  disposeObj(objReferenceName) {\n    delete this.objReferenceDict[objReferenceName];\n  }\n\n  //Stores callback for events based on a key. Needed when\n  //Event needs to be removed - the callback can be retrieved and\n  //used to remove the event in question\n  eventCallbackRegistry: { [key: string]: eventCallback} = {};\n  \n  oldBodyCacheStack = [];\n\n  private constructor() { }\n\n  static getInstance() {\n    if (!this.instance) {\n      this.instance = new State();      \n    }\n    return this.instance;\n  }\n}\n\nexport const state = State.getInstance();","﻿import { infoHelper as domInfoHelper } from './dom/infoHelper';\n\nexport class styleHelper {\n  static addCls(selector: Element | string, className: string | Array<string>) {\n    let element = domInfoHelper.get(selector);\n    if (element) {\n      if (typeof className === \"string\") {\n        element.classList.add(className);\n      } else {\n        element.classList.add(...className);\n      }\n    }\n  }\n\n  static removeCls(selector: Element | string, clsName: string | Array<string>) {\n    let element = domInfoHelper.get(selector);\n    if (element) {\n      if (typeof clsName === \"string\") {\n        element.classList.remove(clsName);\n      } else {\n        element.classList.remove(...clsName);\n      }\n    }\n  }\n\n  static addClsToFirstChild(element: Element | string, className: string): void {\n    var domElement = domInfoHelper.get(element);\n    if (domElement && domElement.firstElementChild) {\n      domElement.firstElementChild.classList.add(className);\n    }\n  }\n\n  static removeClsFromFirstChild(element: Element | string, className): void {\n    var domElement = domInfoHelper.get(element);\n    if (domElement && domElement.firstElementChild) {\n      domElement.firstElementChild.classList.remove(className);\n    }\n  }\n\n  static matchMedia(query: string): boolean {\n    return window.matchMedia(query).matches;\n  }\n\n  static getStyle(element, styleProp: string) {\n    if (element.currentStyle)\n      return element.currentStyle[styleProp];\n    else if (window.getComputedStyle)\n      return document.defaultView.getComputedStyle(element, null).getPropertyValue(styleProp);\n  }\n\n  //Referenced in Caret, class Mirror\n  static css(element: HTMLElement, name: string | object, value: string | null = null) {\n    if (typeof name === 'string') {\n      element.style[name] = value;\n    } else {\n      for (let key in name) {\n        if (name.hasOwnProperty(key)) {\n          element.style[key] = name[key];\n        }\n      }\n    }\n  }\n}","﻿import * as interop from \"./core/JsInterop/interop\";\n\ndeclare global {\n  interface Window {\n    AntDesign: any;\n  }\n}\n\nwindow.AntDesign = {\n  interop,\n};\n"]}